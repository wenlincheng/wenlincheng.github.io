<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis开发规范</title>
      <link href="/posts/5e22.html"/>
      <url>/posts/5e22.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自 <a href="https://yq.aliyun.com/articles/531067" target="_blank" rel="noopener">https://yq.aliyun.com/articles/531067</a></p></blockquote><h3 id="一、键值设计"><a href="#一、键值设计" class="headerlink" title="一、键值设计"></a>一、键值设计</h3><h4 id="1-key名设计"><a href="#1-key名设计" class="headerlink" title="1. key名设计"></a>1. key名设计</h4><ul><li>(1)【建议】: 可读性和可管理性</li></ul><p>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p><pre class="line-numbers language-xml"><code class="language-xml">ugc:video:1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>(2)【建议】：简洁性</li></ul><p>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p><pre class="line-numbers language-xml"><code class="language-xml">user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>(3)【强制】：不要包含特殊字符</li></ul><p>反例：包含空格、换行、单双引号以及其他转义字符</p><p><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2NTEyNzE0OA%3D%3D%26amp%3Bmid%3D2247483663%26amp%3Bidx%3D1%26amp%3Bsn%3D7c4ad441eaec6f0ff38d1c6a097b1fa4%26amp%3Bchksm%3Dce5f9e8cf928179a2c74227da95bec575bdebc682e8630b5b1bb2071c0a1b4be6f98d67c37ca%26amp%3Bscene%3D21%23wechat_redirect" target="_blank" rel="noopener">详细解析</a></p><h4 id="2-value设计"><a href="#2-value设计" class="headerlink" title="2. value设计"></a>2. value设计</h4><ul><li>(1)【强制】：拒绝bigkey(防止网卡流量、慢查询)</li></ul><p>string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</p><p>反例：一个包含200万个元素的list。</p><p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=%23cc1" target="_blank" rel="noopener">查找方法</a>和<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=%23cc2" target="_blank" rel="noopener">删除方法</a></p><p><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2NTEyNzE0OA%3D%3D%26amp%3Bmid%3D2247483677%26amp%3Bidx%3D1%26amp%3Bsn%3D5c320b46f0e06ce9369a29909d62b401%26amp%3Bchksm%3Dce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec%26amp%3Bscene%3D21%23wechat_redirect" target="_blank" rel="noopener">详细解析</a></p><ul><li>(2)【推荐】：选择适合的数据类型。</li></ul><p>例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡)</p><p>反例：</p><pre><code>set user:1:name tomset user:1:age 19set user:1:favor football</code></pre><p>正例:</p><pre><code>hmset user:1 name tom age 19 favor football</code></pre><h4 id="3-【推荐】：控制key的生命周期，redis不是垃圾桶。"><a href="#3-【推荐】：控制key的生命周期，redis不是垃圾桶。" class="headerlink" title="3.【推荐】：控制key的生命周期，redis不是垃圾桶。"></a>3.【推荐】：控制key的生命周期，redis不是垃圾桶。</h4><p>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。</p><h3 id="二、命令使用"><a href="#二、命令使用" class="headerlink" title="二、命令使用"></a>二、命令使用</h3><h4 id="1-【推荐】-O-N-命令关注N的数量"><a href="#1-【推荐】-O-N-命令关注N的数量" class="headerlink" title="1.【推荐】 O(N)命令关注N的数量"></a>1.【推荐】 O(N)命令关注N的数量</h4><p>例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。</p><h4 id="2-【推荐】：禁用命令"><a href="#2-【推荐】：禁用命令" class="headerlink" title="2.【推荐】：禁用命令"></a>2.【推荐】：禁用命令</h4><p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p><h4 id="3-【推荐】合理使用select"><a href="#3-【推荐】合理使用select" class="headerlink" title="3.【推荐】合理使用select"></a>3.【推荐】合理使用select</h4><p>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p><h4 id="4-【推荐】使用批量操作提高效率"><a href="#4-【推荐】使用批量操作提高效率" class="headerlink" title="4.【推荐】使用批量操作提高效率"></a>4.【推荐】使用批量操作提高效率</h4><pre><code>原生命令：例如mget、mset。非原生命令：可以使用pipeline提高效率。</code></pre><p>但要注意控制一次批量操作的<strong>元素个数</strong>(例如500以内，实际也和元素字节数有关)。</p><p>注意两者不同：</p><pre><code>1. 原生是原子操作，pipeline是非原子操作。2. pipeline可以打包不同的命令，原生做不到3. pipeline需要客户端和服务端同时支持。</code></pre><h4 id="5-【建议】Redis事务功能较弱，不建议过多使用"><a href="#5-【建议】Redis事务功能较弱，不建议过多使用" class="headerlink" title="5.【建议】Redis事务功能较弱，不建议过多使用"></a>5.【建议】Redis事务功能较弱，不建议过多使用</h4><p>Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)</p><h4 id="6-【建议】Redis集群版本在使用Lua上有特殊要求："><a href="#6-【建议】Redis集群版本在使用Lua上有特殊要求：" class="headerlink" title="6.【建议】Redis集群版本在使用Lua上有特殊要求："></a>6.【建议】Redis集群版本在使用Lua上有特殊要求：</h4><ul><li>1.所有key都应该由 KEYS 数组来传递，redis.call/pcall 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，”-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS array”</li><li>2.所有key，必须在1个slot上，否则直接返回error, “-ERR eval/evalsha command keys must in same slot”</li></ul><h4 id="7-【建议】必要情况下使用monitor命令时，要注意不要长时间使用。"><a href="#7-【建议】必要情况下使用monitor命令时，要注意不要长时间使用。" class="headerlink" title="7.【建议】必要情况下使用monitor命令时，要注意不要长时间使用。"></a>7.【建议】必要情况下使用monitor命令时，要注意不要长时间使用。</h4><h3 id="三、客户端使用"><a href="#三、客户端使用" class="headerlink" title="三、客户端使用"></a>三、客户端使用</h3><h4 id="1-【推荐】"><a href="#1-【推荐】" class="headerlink" title="1.【推荐】"></a>1.【推荐】</h4><p>避免多个应用使用一个Redis实例</p><p>正例：不相干的业务拆分，公共数据做服务化。</p><h4 id="2-【推荐】"><a href="#2-【推荐】" class="headerlink" title="2.【推荐】"></a>2.【推荐】</h4><p>使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：</p><pre class="line-numbers language-java"><code class="language-java">执行命令如下：Jedis jedis <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    jedis <span class="token operator">=</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//具体的命令</span>    jedis<span class="token punctuation">.</span><span class="token function">executeCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"op key {} error: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>jedis <span class="token operator">!=</span> null<span class="token punctuation">)</span>         jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是JedisPool优化方法的文章:</p><ul><li><a href="https://yq.aliyun.com/articles/236384" target="_blank" rel="noopener">Jedis常见异常汇总</a></li><li><a href="https://yq.aliyun.com/articles/236383" target="_blank" rel="noopener">JedisPool资源池优化</a></li></ul><h4 id="3-【建议】"><a href="#3-【建议】" class="headerlink" title="3.【建议】"></a>3.【建议】</h4><p>高并发下建议客户端添加熔断功能(例如netflix hystrix)</p><h4 id="4-【推荐】"><a href="#4-【推荐】" class="headerlink" title="4.【推荐】"></a>4.【推荐】</h4><p>设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持）</p><h4 id="5-【建议】"><a href="#5-【建议】" class="headerlink" title="5.【建议】"></a>5.【建议】</h4><p>根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。</p><p>默认策略是 volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。</p><h5 id="其他策略如下："><a href="#其他策略如下：" class="headerlink" title="其他策略如下："></a>其他策略如下：</h5><ul><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li><li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li><li>volatile-random:随机删除过期键，直到腾出足够空间为止。</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</li><li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li></ul><h3 id="四、相关工具"><a href="#四、相关工具" class="headerlink" title="四、相关工具"></a>四、相关工具</h3><h4 id="1-【推荐】：数据同步"><a href="#1-【推荐】：数据同步" class="headerlink" title="1.【推荐】：数据同步"></a>1.【推荐】：数据同步</h4><p>redis间数据同步可以使用：redis-port</p><h4 id="2-【推荐】：big-key搜索"><a href="#2-【推荐】：big-key搜索" class="headerlink" title="2.【推荐】：big key搜索"></a>2.【推荐】：big key搜索</h4><p><a href="https://yq.aliyun.com/articles/117042" target="_blank" rel="noopener">redis大key搜索工具</a></p><h4 id="3-【推荐】：热点key寻找-内部实现使用monitor，所以建议短时间使用"><a href="#3-【推荐】：热点key寻找-内部实现使用monitor，所以建议短时间使用" class="headerlink" title="3.【推荐】：热点key寻找(内部实现使用monitor，所以建议短时间使用)"></a>3.【推荐】：热点key寻找(内部实现使用monitor，所以建议短时间使用)</h4><p><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fgithub.com%2Ffacebookarchive%2Fredis-faina" target="_blank" rel="noopener">facebook的redis-faina</a></p><pre><code>阿里云Redis已经在内核层面解决热点key问题，欢迎使用。</code></pre><h2 id="五-附录：删除bigkey"><a href="#五-附录：删除bigkey" class="headerlink" title="五 附录：删除bigkey"></a>五 附录：删除bigkey</h2><pre><code>1. 下面操作可以使用pipeline加速。2. redis 4.0已经支持key的异步删除，欢迎使用。</code></pre><h5 id="1-Hash删除-hscan-hdel"><a href="#1-Hash删除-hscan-hdel" class="headerlink" title="1. Hash删除: hscan + hdel"></a>1. Hash删除: hscan + hdel</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delBigHash</span><span class="token punctuation">(</span>String host<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> String password<span class="token punctuation">,</span> String bigHashKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Jedis jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>password <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ScanParams scanParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScanParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String cursor <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        ScanResult<span class="token operator">&lt;</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> scanResult <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hscan</span><span class="token punctuation">(</span>bigHashKey<span class="token punctuation">,</span> cursor<span class="token punctuation">,</span> scanParams<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> entryList <span class="token operator">=</span> scanResult<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>entryList <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>entryList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> entryList<span class="token punctuation">)</span> <span class="token punctuation">{</span>                jedis<span class="token punctuation">.</span><span class="token function">hdel</span><span class="token punctuation">(</span>bigHashKey<span class="token punctuation">,</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        cursor <span class="token operator">=</span> scanResult<span class="token punctuation">.</span><span class="token function">getStringCursor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token string">"0"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>cursor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//删除bigkey</span>    jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>bigHashKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-List删除-ltrim"><a href="#2-List删除-ltrim" class="headerlink" title="2. List删除: ltrim"></a>2. List删除: ltrim</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delBigList</span><span class="token punctuation">(</span>String host<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> String password<span class="token punctuation">,</span> String bigListKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Jedis jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>password <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">long</span> llen <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">llen</span><span class="token punctuation">(</span>bigListKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>counter <span class="token operator">&lt;</span> llen<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//每次从左侧截掉100个</span>        jedis<span class="token punctuation">.</span><span class="token function">ltrim</span><span class="token punctuation">(</span>bigListKey<span class="token punctuation">,</span> left<span class="token punctuation">,</span> llen<span class="token punctuation">)</span><span class="token punctuation">;</span>        counter <span class="token operator">+=</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//最终删除key</span>    jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>bigListKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-Set删除-sscan-srem"><a href="#3-Set删除-sscan-srem" class="headerlink" title="3. Set删除: sscan + srem"></a>3. Set删除: sscan + srem</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delBigSet</span><span class="token punctuation">(</span>String host<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> String password<span class="token punctuation">,</span> String bigSetKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Jedis jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>password <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ScanParams scanParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScanParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String cursor <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        ScanResult<span class="token operator">&lt;</span>String<span class="token operator">></span> scanResult <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">sscan</span><span class="token punctuation">(</span>bigSetKey<span class="token punctuation">,</span> cursor<span class="token punctuation">,</span> scanParams<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> memberList <span class="token operator">=</span> scanResult<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>memberList <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>memberList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>String member <span class="token operator">:</span> memberList<span class="token punctuation">)</span> <span class="token punctuation">{</span>                jedis<span class="token punctuation">.</span><span class="token function">srem</span><span class="token punctuation">(</span>bigSetKey<span class="token punctuation">,</span> member<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        cursor <span class="token operator">=</span> scanResult<span class="token punctuation">.</span><span class="token function">getStringCursor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token string">"0"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>cursor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//删除bigkey</span>    jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>bigSetKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-SortedSet删除-zscan-zrem"><a href="#4-SortedSet删除-zscan-zrem" class="headerlink" title="4. SortedSet删除: zscan + zrem"></a>4. SortedSet删除: zscan + zrem</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delBigZset</span><span class="token punctuation">(</span>String host<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> String password<span class="token punctuation">,</span> String bigZsetKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Jedis jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>password <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ScanParams scanParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScanParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String cursor <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        ScanResult<span class="token operator">&lt;</span>Tuple<span class="token operator">></span> scanResult <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">zscan</span><span class="token punctuation">(</span>bigZsetKey<span class="token punctuation">,</span> cursor<span class="token punctuation">,</span> scanParams<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Tuple<span class="token operator">></span> tupleList <span class="token operator">=</span> scanResult<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tupleList <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>tupleList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Tuple tuple <span class="token operator">:</span> tupleList<span class="token punctuation">)</span> <span class="token punctuation">{</span>                jedis<span class="token punctuation">.</span><span class="token function">zrem</span><span class="token punctuation">(</span>bigZsetKey<span class="token punctuation">,</span> tuple<span class="token punctuation">.</span><span class="token function">getElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        cursor <span class="token operator">=</span> scanResult<span class="token punctuation">.</span><span class="token function">getStringCursor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token string">"0"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>cursor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//删除bigkey</span>    jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>bigZsetKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL面试5连炮</title>
      <link href="/posts/e47c.html"/>
      <url>/posts/e47c.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、描述下MySQL的架构体系？"><a href="#1、描述下MySQL的架构体系？" class="headerlink" title="1、描述下MySQL的架构体系？"></a>1、描述下MySQL的架构体系？</h3><h3 id="2、MySQL的常用存储引擎及他们之间的区别？"><a href="#2、MySQL的常用存储引擎及他们之间的区别？" class="headerlink" title="2、MySQL的常用存储引擎及他们之间的区别？"></a>2、MySQL的常用存储引擎及他们之间的区别？</h3><h3 id="3、MySQL索引的实现机制是什么，为什么要使用B-树？"><a href="#3、MySQL索引的实现机制是什么，为什么要使用B-树？" class="headerlink" title="3、MySQL索引的实现机制是什么，为什么要使用B+树？"></a>3、MySQL索引的实现机制是什么，为什么要使用B+树？</h3><h3 id="4、MySQL中的事务实现原理？"><a href="#4、MySQL中的事务实现原理？" class="headerlink" title="4、MySQL中的事务实现原理？"></a>4、MySQL中的事务实现原理？</h3><h3 id="5、MySQL有哪些常用的优化策略？"><a href="#5、MySQL有哪些常用的优化策略？" class="headerlink" title="5、MySQL有哪些常用的优化策略？"></a>5、MySQL有哪些常用的优化策略？</h3><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具】Typro PicGo 和 Md2All 玩转 Markdown 排版编辑</title>
      <link href="/posts/324a.html"/>
      <url>/posts/324a.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><em>工欲善其事，必先利其器</em>。想要高效的写出精彩的文章，需要创作者对相关领域知识的了解有足够的深度和广度，与此同时也离不开选择一套合适的排版编辑工具。如果你是不要求排版花里胡哨的创作者，并且写的文章需要同时发表在微信公众号、博客园、掘金、CSDN、个人网站等平台，在这里推荐使用 <code>Typro</code> <code>PicGo</code> 和<code>Md2All</code>的工具组合，进行 <code>Markdown</code>排版编辑。理由很简单，用着就是爽。</p><h3 id="Typro编辑器"><a href="#Typro编辑器" class="headerlink" title="Typro编辑器"></a>Typro编辑器</h3><blockquote><p>Typora给用户既是读者又是作家的无缝体验。它删除了预览窗口，模式切换器，降低源代码的语法符号以及所有其他不必要的干扰。相反，它提供了真正的实时预览功能，可帮助用户专注于内容本身。</p></blockquote><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p><code>Typro</code> 是个人觉得最方便、最简洁的 Markdown 桌面编辑器，支持标准的 Markdown 语法，提供了真正实时预览、文件管理、内容定位、文件导入导出、图片上传、主题选择等功能，以及专注模式和打字机模式使创作更方便。目前，可在 <a href="https://typora.io/" target="_blank" rel="noopener">官网下载</a> 公测版使用，支持 <code>MacOS</code> 、<code>Windows</code>、<code>Linux</code> 三大操作系统。</p><p align="center">  <video id="video" controls="" preload="none" poster="" style="width: 67%;">        <source id="mp4" src="http://img.wenlincheng.com/typro.mp4" type="video/mp4">    </video></p><h5 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h5><p>这里主要介绍如何设置图片自动上传至图床的功能。在 <code>格式&gt;图像&gt;全局图像设置</code> 配置图片上传服务，上传服务有很多选项，我们选用<code>PicGo</code>图床管理工具，用于添加图片到文件中时，自动上传图片至设置的图床中。具体设置，选择在插入图片时执行的操作为<code>上传图片</code>，在上传服务选项选择使用 <code>PicGo.app</code>进行上传。</p><p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306153154.png" alt="上传服务"></p><h3 id="PicGo图床工具"><a href="#PicGo图床工具" class="headerlink" title="PicGo图床工具"></a>PicGo图床工具</h3><p>前面我们设置好了<code>Typro</code>图片自动上传，然而并不能实现上传功能，我们还需要一款图床管理工具。所谓图床工具，就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具，就目前使用种类而言，<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo</a> 算得上一款比较优秀的图床工具了。它是一款用 <code>Electron-vue</code> 开发的软件，可以支持微博、七牛云、腾讯云COS、又拍云、GitHub、阿里云OSS、SM.MS、Imgur 等8种常用图床，功能强大，简单易用。</p><p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200309175612.png" alt="图床支持"></p><p>上传图片前需要先设置对应图床的<code>AccessKey</code>和<code>SecretKey</code>，以下为七牛云图床的设置。在七牛云注册个人账号，实名认证后，可免费获取<code>10G</code>的存储空间，具体获取方法可参考网上的教程。</p><p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200309175418.png" alt="图床设置"></p><h3 id="Md2All-排版利器"><a href="#Md2All-排版利器" class="headerlink" title="Md2All 排版利器"></a>Md2All 排版利器</h3><p><a href="http://md.aclickall.com/" target="_blank" rel="noopener">Md2All</a> 是一款网页版的 Markdown 排版利器，支持一键排版，让原本朴实无华的 Markdown 文档也变的“花里胡哨”了。<code>Md2All</code> 还能让 Markdown 内容，无需作任何调整就能同时在微信公众号、博客园、掘金、CSDN等多平台正确显示当前预览的效果，正所谓一次编写，处处发（zhuang）表（x），具体使用方法可参考作者写的 <a href="https://mp.weixin.qq.com/s/oGcqB5ALGO49hLGLu1LquQ" target="_blank" rel="noopener">Md2All使用教程</a>。</p><p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200309175122.png" alt="Md2All"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>看到最后大家可能有有点疑惑，为什么不直接使用网页版的 <code>Md2All</code> 进行编辑呢，<code>Md2All</code> 本身是可以设置图床自动上传图片的。主要原因有三点，首先是自己平常有清理浏览器缓存的习惯，并且开发过程中也有不得不清理缓存的情况，而 <code>Md2All</code> 的数据是保存在浏览器缓存中的，担心哪一次手抖就把辛辛苦苦写好的文章给清理了，那就哭也没用了；再一个是我的<a href="htttps://www.wenlincheng.com">个人网站</a>用的是<code>Hexo</code>，使用 <code>Typro</code> 编辑发布到网站上很方便，最后就是 <code>Typro</code> 的简洁，以及强大的实时预览功能令我爱不释手，所以 <code>Md2All</code> 在这里是一个编辑美化、格式转换的工具。本文仅仅对个人喜欢的排版工具进行简单的介绍，在一段时间的使用后觉得不错就推荐给大家了，如果有更好的排版工具，欢迎分享推荐。</p><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB用户权限</title>
      <link href="/posts/6eea.html"/>
      <url>/posts/6eea.html</url>
      
        <content type="html"><![CDATA[<h3 id="权限简介"><a href="#权限简介" class="headerlink" title="权限简介"></a>权限简介</h3><p>安装 MongoDB 后默认是不开启权限访问控制的，MongoDB 的权限控制是基于用户-角色进行鉴权的，我们可以在配置文件中设置开启，并创建用户分配相应的角色。</p><h3 id="内置角色"><a href="#内置角色" class="headerlink" title="内置角色"></a>内置角色</h3><p>Built-In Roles（<a href="http://docs.mongodb.org/manual/reference/built-in-roles/#built-in-roles" target="_blank" rel="noopener">内置角色</a>）：</p><ul><li><p>数据库用户角色：read、readWrite</p></li><li><p>数据库管理角色：dbAdmin、dbOwner、userAdmin</p></li><li><p>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager</p></li><li><p>备份恢复角色：backup、restore</p></li><li><p>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</p></li><li><p>超级用户角色：root </p><p>dbOwner 、userAdmin、userAdminAnyDatabase 角色间接或直接提供了系统超级用户的访问。</p></li><li><p>内部角色：__system</p></li></ul><p>修改 mongo.conf 配置文件，将参数 auth 的值设置为 true</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 数据文件存放目录</span>dbpath<span class="token operator">=</span>/usr/local/mongodb/data<span class="token comment" spellcheck="true"># 事先创建该文件</span>logpath<span class="token operator">=</span>/usr/local/mongodb/logs/mongo.loglogappend<span class="token operator">=</span>truejournal<span class="token operator">=</span>truequiet<span class="token operator">=</span>trueport<span class="token operator">=</span>27017<span class="token comment" spellcheck="true"># 后台作为守护进程运行</span>fork<span class="token operator">=</span>true<span class="token comment" spellcheck="true"># 允许任何IP进行连接</span>bind_ip<span class="token operator">=</span>0.0.0.0<span class="token comment" spellcheck="true"># 开启权限认证</span>auth<span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启用权限访问控制后，需要确保在 <code>admin</code> 数据库中拥有一个具有 <code>userAdmin</code>或<code>userAdminAnyDatabase</code>角色的用户。 该用户可以管理用户和角色，例如：创建用户、向用户授予或撤消角色，以及创建或修改自定义角色。</p><h3 id="创建用户分配角色"><a href="#创建用户分配角色" class="headerlink" title="创建用户分配角色"></a>创建用户分配角色</h3><p>在mongo shell中，在admin数据库中添加一个具有<code>userAdminAnyDatabase</code>角色的用户。 包括此用户所需的其他角色。 例如，以下代码在user数据库中使用<code>userAdminAnyDatabase</code>角色和<code>readWriteAnyDatabase</code>角色创建用户 myUserAdmin。</p><pre class="line-numbers language-bash"><code class="language-bash">use admindb.createUser<span class="token punctuation">(</span>  <span class="token punctuation">{</span>    user: <span class="token string">"myUserAdmin"</span>,    pwd: <span class="token string">"123456"</span>,    roles: <span class="token punctuation">[</span> <span class="token punctuation">{</span> role: <span class="token string">"userAdminAnyDatabase"</span>, db: <span class="token string">"admin"</span> <span class="token punctuation">}</span>, <span class="token string">"readWriteAnyDatabase"</span> <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：</p><p><a href="https://docs.mongodb.com/v4.0/tutorial/enable-authentication/" target="_blank" rel="noopener">Enable Access Control</a></p><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB系列】CRUD 操作</title>
      <link href="/posts/6eea.html"/>
      <url>/posts/6eea.html</url>
      
        <content type="html"><![CDATA[<hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB系列】Linux系统安装MongoDB</title>
      <link href="/posts/7763.html"/>
      <url>/posts/7763.html</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>MongoDB 是由C++语言编写，一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。</p></blockquote><p><img src="../images/loading.gif" data-original="http://img.ternarytree.cn/blog/image/document.jpg" alt="文档结构-图片来自MongoDB官网"></p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>到 <a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">mongodb官网</a>下载对应系统的安装包，演示安装系统使用的是 <code>Linux CentOS7 X64</code>，安装包选择如下：</p><p><img src="../images/loading.gif" data-original="http://img.ternarytree.cn/blog/image/%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD.jpg" alt="安装包下载-图片截自MongoDB官网"></p><p>使用命令下载</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.2.3.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h3><p>tar 解压</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">tar</span> -zxvf mongodb-linux-x86_64-rhel70-4.2.3.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将解压后的文件夹移动到/usr/local/的mongodb目录下</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在 /usr/local 下创建目录</span><span class="token function">mkdir</span> mongodb<span class="token comment" spellcheck="true"># 移动到 /usr/local/mongodb</span><span class="token function">mv</span> mongodb-linux-x86_64-rhel70-4.2.3 /usr/local/mongodb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>修改配置系统文件 <code>profile</code></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> vim /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>插入以下内容：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># mongodb</span>MONGODB_HOME<span class="token operator">=</span>/usr/local/mongodb/mongodb-linux-x86_64-rhel70-4.2.3PATH<span class="token operator">=</span><span class="token variable">$PATH</span><span class="token keyword">:</span><span class="token variable">$MONGODB_HOME</span>/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>保存后要重启系统配置：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="数据日志"><a href="#数据日志" class="headerlink" title="数据日志"></a>数据日志</h3><p>创建用于存放数据和日志文件的文件夹，并修改其权限增加读写权限</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/mongodb <span class="token function">mkdir</span> data<span class="token function">mkdir</span> logs <span class="token function">cd</span> logs<span class="token function">touch</span> mongo.log <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="启动配置"><a href="#启动配置" class="headerlink" title="启动配置"></a>启动配置</h3><p>增加一个配置文件：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/mongodb vim mongo.conf <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>插入下列内容：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 数据文件存放目录</span>dbpath<span class="token operator">=</span>/usr/local/mongodb/data<span class="token comment" spellcheck="true"># 事先创建该文件</span>logpath<span class="token operator">=</span>/usr/local/mongodb/logs/mongo.loglogappend<span class="token operator">=</span>truejournal<span class="token operator">=</span>truequiet<span class="token operator">=</span>trueport<span class="token operator">=</span>27017<span class="token comment" spellcheck="true">#后台作为守护进程运行</span>fork<span class="token operator">=</span>true<span class="token comment" spellcheck="true">#允许任何IP进行连接</span>bind_ip<span class="token operator">=</span>0.0.0.0<span class="token comment" spellcheck="true"># 权限认证</span><span class="token comment" spellcheck="true"># auth=true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><p>启动mongod数据库服务，以配置文件的方式启动</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/mongodb/mongodb-linux-x86_64-rhel70-4.2.3<span class="token comment" spellcheck="true"># 指定配置文件启动</span>./bin/mongod -f /usr/local/mongodb/mongo.conf<span class="token comment" spellcheck="true"># 查看 mongodb 进程</span><span class="token function">netstat</span> -lanp <span class="token operator">|</span><span class="token function">grep</span> 27017<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>连接到mongodb数据库</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 命令行输入命令直接连接</span>mongo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="关闭命令"><a href="#关闭命令" class="headerlink" title="关闭命令"></a>关闭命令</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 方法1</span><span class="token function">pkill</span> mongod<span class="token comment" spellcheck="true"># 方法2 进入mongo shell </span>db.shuidownServer<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本次安装未开启用户权限认证，命令行输入<code>mongo</code>可直接连接到 mongodb ，为了保证数据的安全型，需要给创建用户，并根据需要分配不同的用户权限（角色），具体操作见下一篇文章。</p><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【碎碎念】——2020-03-01</title>
      <link href="/posts/1708.html"/>
      <url>/posts/1708.html</url>
      
        <content type="html"><![CDATA[<p>阅读记录</p><blockquote><p><a href="https://mp.weixin.qq.com/s/90SH_8wOaqUGTH7a_6FvMw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/90SH_8wOaqUGTH7a_6FvMw</a></p></blockquote><p>左宗棠，曾写过一副对联：</p><p><strong>发上等愿，结中等缘，享下等福；</strong></p><p><strong>择高处立，寻平处住，向宽处行。</strong></p><p>对联解释：</p><p>人要胸怀远大志向，</p><p>但只求中等的缘分，</p><p>愿过普通人的生活；</p><p>看问题要高瞻远瞩，</p><p>做人应该低调谦逊，</p><p>做事要多留些余地。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【碎碎念】——2020-02-28</title>
      <link href="/posts/8dc8.html"/>
      <url>/posts/8dc8.html</url>
      
        <content type="html"><![CDATA[<p>“不要把鸡蛋放在一个篮子里”</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【碎碎念】——2020-02-27</title>
      <link href="/posts/8988.html"/>
      <url>/posts/8988.html</url>
      
        <content type="html"><![CDATA[<p>五年内能让你受益匪浅的事：</p><ul><li>掌握一项赖以谋生的技能——编程</li><li>树立投资理财观念——在学习</li><li>拥有一项令你心静的爱好——看书、摄影</li><li>学会说话，建立高效能人际圈——在努力</li><li>养成良好的习惯——在努力</li></ul><p>10-10-10决策法则</p><p>不知道如何决策时问自己三个问题：</p><ul><li>这个决定在10分钟后有什么影响？</li><li>这个决定在10个月后有什么影响？</li><li>这个决定在10年之后有什么影响？</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【碎碎念】——2020-02-24</title>
      <link href="/posts/88c8.html"/>
      <url>/posts/88c8.html</url>
      
        <content type="html"><![CDATA[<p>两情相悦何须待长发及腰，短发及肩也美若天仙。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【碎碎念】——2020-02-23</title>
      <link href="/posts/4a89.html"/>
      <url>/posts/4a89.html</url>
      
        <content type="html"><![CDATA[<p>“人类每天思考事情占比不足20%，剩下的是习惯。习惯积累，就成了人生”</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python问题】—— 安装pip、PIL</title>
      <link href="/posts/953d.html"/>
      <url>/posts/953d.html</url>
      
        <content type="html"><![CDATA[<p>Python3安装 PIL（Python Image Library）</p><pre class="line-numbers language-bash"><code class="language-bash">pip <span class="token function">install</span> Pillow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>报错</p><pre class="line-numbers language-bash"><code class="language-bash">/usr/local/opt/python/bin/python3.7: No module named pip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装pip即可</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> https://bootstrap.pypa.io/get-pip.py<span class="token function">sudo</span> python3 get-pip.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装 PIL时太慢怎么办？</p><p>1、设置超时时间：pip –default-timeout=100 install  Pillow</p><p>2、不使用缓存：pip  –no-cache-dir install Pillow</p><p>3、使用国内源：pip install web.py -i <a href="http://pypi.douban.com/simple" target="_blank" rel="noopener">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com</p><p>使用国内源提高下载速度</p><pre class="line-numbers language-bash"><code class="language-bash">pip <span class="token function">install</span> -i https://pypi.doubanio.com/simple/ 包名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可用的国内源</p><ul><li><p>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></p></li><li><p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a> </p></li><li><p>豆瓣(douban) <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a> </p></li><li><p>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></p></li><li><p>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></p></li></ul><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven面试题</title>
      <link href="/posts/f4a5.html"/>
      <url>/posts/f4a5.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Maven有哪些优点和缺点？"><a href="#一、Maven有哪些优点和缺点？" class="headerlink" title="一、Maven有哪些优点和缺点？"></a>一、Maven有哪些优点和缺点？</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>简化了项目依赖管理；</li><li>易于上手，对于新手可能一个<code>mvn clean package</code>命令就可能满足他的工作；</li><li>便于与持续集成工具（jenkins）整合；</li><li>便于项目升级，无论是项目本身升级还是项目使用的依赖升级；</li><li>有助于多模块项目的开发，一个模块开发好后，发布到仓库，依赖该模块时可以直接从仓库更新，而不用自己去编译；</li><li>maven有很多插件，便于功能扩展，比如生产站点，自动发布版本等。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>maven是一个庞大的构建系统，学习难度较大；</li><li>maven采用约定优于配置的策略（convention over configuration），虽然上手容易，但是一旦出了问题，难于调试；</li><li>当依赖很多时，编辑器会很卡；</li><li>中国的网络环境差，很多repository无法访问，比如google code， jboss 仓库无法访问等，但是大多数仓库可使用国内镜像解决。</li></ol><h3 id="二、Maven坐标？"><a href="#二、Maven坐标？" class="headerlink" title="二、Maven坐标？"></a>二、Maven坐标？</h3><p>一般maven使用[groupID，artifactId，version，packaging]来表示一个项目的某个版本，有时还会使用classifier来表示项目的附属构建，常见的附属构建有javadoc和sources包。</p><h3 id="三、Maven常见的依赖范围有哪些"><a href="#三、Maven常见的依赖范围有哪些" class="headerlink" title="三、Maven常见的依赖范围有哪些?"></a>三、Maven常见的依赖范围有哪些?</h3><ol><li><strong>compile</strong>：编译依赖，默认的依赖方式，在编译（编译项目和编译测试用例），运行测试用例，运行（项目实际运行）三个阶段都有效，典型地有spring-core等jar；</li><li><strong>test</strong>：测试依赖，只在编译测试用例和运行测试用例有效，典型地有JUnit；</li><li><strong>provided</strong>：对于编译和测试有效，不会打包进发布包中，典型的例子为servlet-api，一般的web工程运行时都使用容器的servlet-api；</li><li><strong>runtime</strong>：只在运行测试用例和实际运行时有效，典型地是jdbc驱动jar包；</li><li><strong>system</strong>：不从maven仓库获取该jar，而是通过systemPath指定该jar的路径；</li><li><strong>import</strong>：用于一个dependencyManagement对另一个dependencyManagement的继承。</li></ol><h3 id="四、Maven的生命周期？"><a href="#四、Maven的生命周期？" class="headerlink" title="四、Maven的生命周期？"></a>四、Maven的生命周期？</h3><p>maven有三套生命周期，分别为：</p><h4 id="clean-周期"><a href="#clean-周期" class="headerlink" title="clean 周期"></a>clean 周期</h4><p>主要用于清理上一次构建产生的文件，可以理解为删除 target 目录。</p><h4 id="默认周期"><a href="#默认周期" class="headerlink" title="默认周期"></a>默认周期</h4><p>主要阶段包含:</p><ol><li>process-resources 默认处理src/test/resources/下的文件，将其输出到测试的classpath目录中；</li><li>compile 编译src/main/java下的java文件，产生对应的class；</li><li>process-test-resources 默认处理src/test/resources/下的文件，将其输出到测试的classpath目录中；</li><li>test-compile 编译src/test/java下的java文件，产生对应的class；</li><li>test 运行测试用例；</li><li>package 打包构件，即生成对应的jar, war等；</li><li>install将构件部署到本地仓库；</li><li>deploy 部署构件到远程仓库。</li></ol><h4 id="site周期"><a href="#site周期" class="headerlink" title="site周期"></a>site周期</h4><p>主要阶段包含</p><ul><li>site 产生项目的站点文档；</li><li>site-deploy 将项目的站点文档部署到服务器。</li></ul><h3 id="五、我们经常使用“Mvn-Clean-Package”命令进行项目打包，请问该命令执行了哪些动作来完成该任务？"><a href="#五、我们经常使用“Mvn-Clean-Package”命令进行项目打包，请问该命令执行了哪些动作来完成该任务？" class="headerlink" title="五、我们经常使用“Mvn Clean Package”命令进行项目打包，请问该命令执行了哪些动作来完成该任务？"></a>五、我们经常使用“Mvn Clean Package”命令进行项目打包，请问该命令执行了哪些动作来完成该任务？</h3><p>在这个命令中我们调用了maven的clean周期的clean阶段绑定的插件任务，以及default周期的package阶段绑定的插件任务<br>默认执行的任务有（maven的术语叫goal, 也有人翻译成目标，我这里用任务）：</p><ul><li>maven-clean-plugin:clean-&gt;</li><li>maven-resources-plugin:resources-&gt;</li><li>maven-compile-plugin:compile-&gt;</li><li>mavne-resources-plugin:testResources-&gt;</li><li>maven-compile-plugin:testCompile-&gt;</li><li>maven-jar-plugin:jar</li></ul><h3 id="六、依赖的解析机制？"><a href="#六、依赖的解析机制？" class="headerlink" title="六、依赖的解析机制？"></a>六、依赖的解析机制？</h3><ol><li>解析发布版本：如果本地有，直接使用本地的，没有就向远程仓库请求。</li><li>解析快照版本：合并本地和远程仓库的元数据文件-groupId/artifactId/version/maven-metadata.xml，这个文件存的版本都是带时间戳的，将最新的一个改名为不带时间戳的格式供本次编译使用。</li><li>解析版本为LATEST,RELEASE，过于复杂，且解析的结果不稳定， 不推荐在项目中使用，感兴趣的同学自己去研究，简而言之就是合并groupId/artifactId/maven-metadata.xml找到对应的最新版本和包含快照的最新版本。</li></ol><h3 id="七、插件的解析机制？"><a href="#七、插件的解析机制？" class="headerlink" title="七、插件的解析机制？"></a>七、插件的解析机制？</h3><p>当我们输入<code>mvn dependency:tree</code>这样的指令，解析的步骤为：<br>解析groupID:<br>maven使用默认的groupID:”org.apache.maven.plugins”或者”org.codehaus.mojo”<br>解析artifactId(maven的官方叫做插件前缀解析策略)<br>合并该groupId在所有仓库中的元数据库文件（maven-metadata-repository.xml），比如maven官方插件的元数据文件所在的目录为org\apache\maven\plugins，该文件下有如下的条目</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>Maven Dependency Plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prefix</span><span class="token punctuation">></span></span>dependency<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prefix</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-dependency-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过比较这样的条目，我们就将该命令的artifactId解析为maven-dependency-plugin<br>解析version，如果你在项目的pom中声明了该插件的版本，那么直接使用该版本的插件，否则合并所有仓库中groupId/artifactId/maven-metadata-repository.xml，找到最新的发布版本。</p><p>对于非官方的插件，有如下两个方法可以选择：<br>1）使用groupId:artifactId:version:goal 来运行；<br>2）在Settings.xml中添加pluginGroup项，这样maven不能在官方的插件库中解析到某个插件，那么就可以去你配置的group下查找。</p><h3 id="八、多模块如何聚合？"><a href="#八、多模块如何聚合？" class="headerlink" title="八、多模块如何聚合？"></a>八、多模块如何聚合？</h3><p>配置一个打包类型为pom的聚合模块，然后在该pom中使用<code>&lt;moudle&gt;</code>元素声明要聚合的模块。</p><h3 id="九、对于一个多模块项目，如果管理项目依赖的版本？"><a href="#九、对于一个多模块项目，如果管理项目依赖的版本？" class="headerlink" title="九、对于一个多模块项目，如果管理项目依赖的版本？"></a>九、对于一个多模块项目，如果管理项目依赖的版本？</h3><p>通过在父模块中声明 dependencyManagement 和 pluginManagement， 然后让子模块通过<code>&lt;parent&gt;</code>元素指定父模块，这样子模块在定义依赖是就可以只定义 groupId 和 artifactId，自动使用父模块的 version,这样统一整个项目的依赖的版本。</p><h3 id="十、一个项目的依赖来源于不同的组织，可能这些依赖还会依赖别的Jar包，如何保证这些传递依赖不会引起版本冲突？"><a href="#十、一个项目的依赖来源于不同的组织，可能这些依赖还会依赖别的Jar包，如何保证这些传递依赖不会引起版本冲突？" class="headerlink" title="十、一个项目的依赖来源于不同的组织，可能这些依赖还会依赖别的Jar包，如何保证这些传递依赖不会引起版本冲突？"></a>十、一个项目的依赖来源于不同的组织，可能这些依赖还会依赖别的Jar包，如何保证这些传递依赖不会引起版本冲突？</h3><p>使用<code>&lt;dependency&gt;</code>的<code>&lt;exclusion&gt;</code>元素将会引起冲突的元素排除。</p><h3 id="十一、常见的Maven私服的仓库类型？"><a href="#十一、常见的Maven私服的仓库类型？" class="headerlink" title="十一、常见的Maven私服的仓库类型？"></a>十一、常见的Maven私服的仓库类型？</h3><p>（宿主仓库）hosted repository, （代理仓库）proxy repository, （仓库组）group repository</p><h3 id="十二、如何查询一个插件有哪些目标（Goal）？"><a href="#十二、如何查询一个插件有哪些目标（Goal）？" class="headerlink" title="十二、如何查询一个插件有哪些目标（Goal）？"></a>十二、如何查询一个插件有哪些目标（Goal）？</h3><p>mvn help:describe -Dplugin=groupId:artifactId</p><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试题</title>
      <link href="/posts/a822.html"/>
      <url>/posts/a822.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/csdnlijingran/article/details/88068598" target="_blank" rel="noopener">https://blog.csdn.net/csdnlijingran/article/details/88068598</a></p><h3 id="1、为什么Redis这么快？"><a href="#1、为什么Redis这么快？" class="headerlink" title="1、为什么Redis这么快？"></a>1、为什么Redis这么快？</h3><p>100000 + QPS（Query pre Second 美秒查询次数）</p><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高；</p><p>2、数据结构简单，对数据操作也简单；</p><p>3、采用单线程，单线程也能处理高并发请求，想多核也可启动多实例；</p><p>4、使用多路I/O复用模型，非阻塞IO。</p><h3 id="2、Redis数据类型有哪些？"><a href="#2、Redis数据类型有哪些？" class="headerlink" title="2、Redis数据类型有哪些？"></a>2、Redis数据类型有哪些？</h3><p>常用数据类型：</p><ul><li>string: 字符串</li><li>hash: 散列</li><li>list: 列表</li><li>set: 集合</li><li>sorted set: 有序集合</li></ul><h4 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h4><p><strong>string</strong> 是 Redis 最基本的数据类型，存储简单的key-value类型，值最大能存储 512MB，是二进制安全的，可以包含任何数据，比如jpg图片、序列化的对象、数字等。</p><p>主要用到的命令有：</p><table><thead><tr><th>命令</th><th>格式</th><th>用例</th><th>描述</th></tr></thead><tbody><tr><td>SET</td><td>SET <code>key</code> <code>value</code></td><td>Blog:0&gt;SET name Tom<br>“OK”</td><td>将键 <code>key</code> 存储值为 <code>value</code></td></tr><tr><td>GET</td><td>GET <code>key</code></td><td>Blog:0&gt;GET name<br>“Tom”</td><td>获取键 <code>key</code> 的值</td></tr><tr><td>GETSET</td><td>GETSET <code>key</code> <code>value</code></td><td>Blog:0&gt;GETSET name Jack<br>“Tom” Blog:0&gt;GET name<br>“Jack”</td><td>将给定 <code>key</code> 的值设为 <code>value</code> ，并返回 <code>key</code> 的旧值(old value)</td></tr><tr><td>INCR</td><td>INCR <code>key</code></td><td>Blog:0&gt;SET num 1<br>“OK” <br>Blog:0&gt;INCR num<br>“2”</td><td>将键 <code>key</code> 存储的值加上 1</td></tr><tr><td>DECR</td><td>DECR <code>key</code></td><td>Blog:0&gt;DECR num<br>“1”</td><td>将键 <code>key</code> 存储的值减去 1</td></tr><tr><td>INCRBY</td><td>INCRBY <code>key</code> <code>n</code></td><td>Blog:0&gt;INCRBY num 2<br>“3”</td><td>将键 <code>key</code> 存储的值加上整数 <code>n</code></td></tr><tr><td>DECRBY</td><td>DECRBY <code>key</code> <code>n</code></td><td>Blog:0&gt;DECRBY num 2<br>“1”</td><td>将键 <code>key</code> 存储的值减去整数 <code>n</code></td></tr><tr><td>INCRBYFLOAT</td><td>INCRBYFLOAT <code>key</code> <code>n</code></td><td>Blog:0&gt;INCRBYFLOAT num <br>0.5<br>Blog:0&gt;INCRBYFLOAT num -0.5<br>“1”</td><td>将键 <code>key</code> 存储的值加上（负数减去）浮点数  <code>n</code></td></tr><tr><td>SETNX</td><td>SETNX <code>key</code> <code>value</code></td><td>Blog:0&gt;SETNX weight 2<br>“1” <br>Blog:0&gt;SETNX weight 3<br>“0”</td><td>用于给指定的 <code>key</code> 设置 <code>value</code>，如果 <code>key</code>已经存在则返回0，设置成功返回1。nx代表:not exist</td></tr><tr><td>SETEX</td><td>SETEX <code>key</code> <code>T</code>             <code>value</code></td><td>Blog:0&gt;SETEX height 10 180<br>Blog:0&gt;GET height<br>“180”<br>Blog:0&gt;GET height<br>null</td><td>用于给指定的 <code>key</code> 设置 <code>value</code>，并且需要指定该 <code>key</code> 的有效时间， T 秒后则返回为 null</td></tr><tr><td>SETRANGE</td><td>SETRANGE <code>key</code> <code>n</code> <code>value</code></td><td>Blog:0&gt;GET name<br>“TomDo”<br>Blog:0&gt;SETRANGE name 3 Ge<br>“5” <br>Blog:0&gt;GET name<br>“TomGe”</td><td>给指定的 <code>key</code> 的值从指定位置（下标从0开始）重新覆盖内容</td></tr><tr><td>GETRANGE</td><td>GETRANGE <code>key</code> <code>n</code> <code>m</code></td><td>Blog:0&gt;GET name<br>“TomGe”<br>Blog:0&gt;GETRANGE name 1 3<br>“omG”</td><td>从下标 n 到 m 获取指定 <code>key</code> 的值的内容</td></tr><tr><td>MSET</td><td>MSET <code>key1</code> <code>value1</code> <code>key2</code> <code>value2</code> ……</td><td>Blog:0&gt;MSET name Tom age 25<br>“OK”</td><td>批量设置值</td></tr><tr><td>MGET</td><td>MGET <code>key1</code> <code>key2</code> ……</td><td>Blog:0&gt;MGET name age<br> 1)  “Tom”<br> 2)  “25”</td><td>批量获取值</td></tr><tr><td>APPEND</td><td>APPEND <code>key</code> <code>value</code></td><td>Blog:0&gt;get name<br>“Jack”<br>Blog:0&gt;APPEND name Tom<br>“7”<br>Blog:0&gt;get name<br>“JackTom”</td><td>如果 <code>key</code> 已经存在并且是一个字符串， APPEND 命令将指定的 <code>value</code> 追加到该 <code>key</code> 原来值<code>value</code>的末尾；<code>key</code> 不存在则设置 <code>value</code>。</td></tr></tbody></table><p>应用场景：</p><ol><li>常规<code>key</code>-<code>value</code>缓存；</li><li>计数功能的缓存：微博粉丝数、点赞数等。</li></ol><h4 id="hash-散列"><a href="#hash-散列" class="headerlink" title="hash 散列"></a>hash 散列</h4><p><strong>Hash</strong>是一个<code>string</code>类型的<code>key</code>和&lt;<code>field</code>,<code>value</code>&gt;的映射表，<code>hash</code>特别适合用于存储对象。 Redis 中每个 hash 可以存储 2^32 - 1 键值对（40多亿）。</p><p>主要用到的命令有：</p><table><thead><tr><th>命令</th><th>格式</th><th>用例</th><th>描述</th></tr></thead><tbody><tr><td>HSET</td><td>HSET <code>key</code> <code>field</code>  <code>value</code></td><td>Blog:0&gt;HSET ec_token 111 nosfhsofhsof<br>“1”</td><td>将哈希表<code>key</code>中的字段<code>field</code>的值设置为<code>value</code>，若<code>key</code>不存在则创建后赋值，若域<code>field</code>已存在则覆盖。</td></tr><tr><td>HDEL</td><td>HDEL <code>key</code> <code>field</code></td><td></td><td></td></tr><tr><td>HEXISTS</td><td>HEXISTS <code>key</code> <code>field</code></td><td></td><td></td></tr><tr><td>HGET</td><td>HGET<code>key</code> <code>field</code></td><td>Blog:0&gt;HGET ec_token 111<br>“nosfhsofhsof”</td><td>从获 <code>key</code> 中取 <code>field</code> 的值</td></tr><tr><td>HGETALL</td><td>HGET <code>key</code></td><td>Blog:0&gt;HGETALL ec_token<br> 1)  “111”<br> 2)  “nosfhsofhsof”<br> 3)  “222”<br> 4)  “vgfndobndb”</td><td>获取<code>key</code>下的所有&lt;field,value&gt; 值</td></tr><tr><td>HINCRBY</td><td>HINCRBY <code>key</code> <code>field</code> <code>n</code></td><td>Blog:0&gt;HSET token a 1<br>“1”<br>Blog:0&gt;HINCRBY token a 2<br>“3”</td><td>哈希表<code>key</code>中的指定字段<code>field</code>的整数值加上增量 <code>n</code></td></tr><tr><td>HINCRBYFLOAT</td><td>HINCRBYFLOAT <code>key</code> <code>field</code> <code>n</code></td><td>Blog:0&gt;HSET token b 0.5<br>“1”<br>Blog:0&gt;HINCRBYFLOAT token b 1.6<br>“2.1”</td><td>哈希表<code>key</code>中的指定字段<code>field</code>的浮点数值加上增量 <code>n</code></td></tr><tr><td>HKEYS</td><td>HKEYS <code>key</code></td><td>Blog:0&gt;HKEYS token<br>1)  “a”  <br>2)  “b”</td><td>获取哈希表中所有的字段</td></tr><tr><td>HVALS</td><td>HVALS <code>key</code></td><td>Blog:0&gt;HVALS token<br>1)  “3”  <br>2)  “2.1”</td><td>获取哈希表中所有字段的值</td></tr><tr><td>HLEN</td><td>HLEN <code>key</code></td><td>Blog:0&gt;HLEN token<br>“2”</td><td>获取哈希表中所有字段的数量</td></tr><tr><td>HMGET</td><td>HMGET <code>key</code> <code>field1</code> <code>[field2]</code></td><td>Blog:0&gt;HMGET token a b<br>1)  “3” <br> 2)  “2.1”</td><td>批量获取哈希表中<code>field</code>字段的值</td></tr><tr><td>HMSET</td><td>HMGET <code>key</code> <code>field1</code>  <code>value1</code> <code>[field2]</code> <code>[value2]</code></td><td>Blog:0&gt;HMSET token c 4 d 6<br>“OK”</td><td>批量设置哈希表中<code>field</code>字段的值</td></tr><tr><td>HSETNX</td><td>HSETNX <code>key</code> <code>field</code>  <code>value</code></td><td>Blog:0&gt;HSETNX token e 7<br>“1”<br>Blog:0&gt;HSETNX token a 7<br>“0”</td><td>字段 <code>field</code> 不存在时，设置哈希表字段的值</td></tr></tbody></table><p>比如可以用<code>Hash</code>数据结构来存储</p><p>应用场景：</p><ul><li>用户信息，商品信息；</li><li>token，在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为<code>field</code>，设置30分钟为缓存过期时间，能很好的模拟出类似<code>session</code>的效果。</li></ul><h4 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h4><p>list就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，最新消息排行等功能都可以用Redis的list结构来实现。</p><p>Redis list的实现为一个<code>双向链表</code>，即可以<code>支持反向查找和遍历</code>，更方便操作，不过带来了部分额外的<code>内存开销</code>。</p><p>使用List的数据结构，可以做<code>简单的消息队列</code>的功能。另外还有一个就是，可以<code>利用lrange命令</code>，做基于redis的<code>分页功能</code>，性能极佳，用户体验好。</p><p>主要用到的命令有：</p><table><thead><tr><th>命令</th><th>格式</th><th>用例</th><th>描述</th></tr></thead><tbody><tr><td>LPUSH</td><td></td><td></td><td>向列表中添加元素</td></tr><tr><td>RPUSH</td><td></td><td></td><td></td></tr><tr><td>LPOP</td><td></td><td></td><td></td></tr><tr><td>RPOP</td><td></td><td></td><td></td></tr><tr><td>LRANGE</td><td></td><td></td><td></td></tr></tbody></table><h4 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h4><p>主要用到的命令有：</p><table><thead><tr><th>命令</th><th>格式</th><th>用例</th><th>描述</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="sorted-set-有序集合"><a href="#sorted-set-有序集合" class="headerlink" title="sorted set 有序集合"></a>sorted set 有序集合</h4><p>主要用到的命令有：</p><table><thead><tr><th>命令</th><th>格式</th><th>用例</th><th>描述</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p>不常用数据类型：</p><ul><li>HyperLogLog：基数统计</li></ul><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【碎碎念】——2020-02-06</title>
      <link href="/posts/2948.html"/>
      <url>/posts/2948.html</url>
      
        <content type="html"><![CDATA[<p>“所有的回忆都在小叮当的口袋里”</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令大全</title>
      <link href="/posts/8a4f.html"/>
      <url>/posts/8a4f.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Git工作原理"><a href="#一、Git工作原理" class="headerlink" title="一、Git工作原理"></a>一、Git工作原理</h3><p><img src="../images/loading.gif" data-original="http://img.ternarytree.cn/blog/cover/Git%E6%96%87%E4%BB%B6%E6%B5%81%E8%BD%AC.jpg" alt="Git文件流转.jpg"></p><p><strong>Git工作区域</strong></p><ul><li><p><strong>Workspace/working directory：工作区</strong></p></li><li><p><strong>Index / Stage：暂存区</strong></p></li><li><p><strong>Repository：仓库区（或本地仓库）</strong></p></li><li><p>Remote：远程仓库</p></li></ul><p><strong>文件的三种状态</strong></p><p>在 Git 中，Git 管理项目时，文件流转的三个工作区域分别为工作目录(working directory)，暂存区域(staging area)，以及本地仓库(repository)，对于任何一个文件，都只有三种状态:<br><strong>已提交(committed)</strong>：表示该文件已经被安全地保存在本地数据库中了；</p><p><strong>已修改(modified)</strong>：表示修改了某个文件，但还没有提交保存；</p><p><strong>已暂存(staged)</strong>：表示把已修改的文件放在下次提交时要保存的清单中。</p><h3 id="二、Git常用命令"><a href="#二、Git常用命令" class="headerlink" title="二、Git常用命令"></a>二、Git常用命令</h3><h4 id="1、新建代码仓库"><a href="#1、新建代码仓库" class="headerlink" title="1、新建代码仓库"></a>1、新建代码仓库</h4><pre class="line-numbers language-bash"><code class="language-bash"> <span class="token comment" spellcheck="true"># 在当前目录新建一个Git代码库</span>$ <span class="token function">git</span> init<span class="token comment" spellcheck="true"># 新建一个目录，将其初始化为Git代码库</span>$ <span class="token function">git</span> init <span class="token punctuation">[</span>project-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 下载一个项目和它的整个代码历史</span>$ <span class="token function">git</span> clone <span class="token punctuation">[</span>url<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、参数配置"><a href="#2、参数配置" class="headerlink" title="2、参数配置"></a>2、参数配置</h4><p>Git的配置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）</p><pre class="line-numbers language-bash"><code class="language-bash"> <span class="token comment" spellcheck="true"># 显示当前的Git配置</span>$ <span class="token function">git</span> config --list<span class="token comment" spellcheck="true"># 编辑Git配置文件</span>$ <span class="token function">git</span> config -e <span class="token punctuation">[</span>--global<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 设置提交代码时的用户信息</span>$ <span class="token function">git</span> config <span class="token punctuation">[</span>--global<span class="token punctuation">]</span> user.name <span class="token string">"[name]"</span>$ <span class="token function">git</span> config <span class="token punctuation">[</span>--global<span class="token punctuation">]</span> user.email <span class="token string">"[email address]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、增加-删除文件"><a href="#3、增加-删除文件" class="headerlink" title="3、增加/删除文件"></a>3、增加/删除文件</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 添加指定文件到暂存区</span>$ <span class="token function">git</span> add <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 添加指定目录到暂存区，包括子目录</span>$ <span class="token function">git</span> add <span class="token punctuation">[</span>dir<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 添加当前目录的所有文件到暂存区</span>$ <span class="token function">git</span> add <span class="token keyword">.</span><span class="token comment" spellcheck="true"># 添加每个变化前，都会要求确认</span><span class="token comment" spellcheck="true"># 对于同一个文件的多处变化，可以实现分次提交</span>$ <span class="token function">git</span> add -p<span class="token comment" spellcheck="true"># 删除工作区文件，并且将这次删除放入暂存区</span>$ <span class="token function">git</span> <span class="token function">rm</span> <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 停止追踪指定文件，但该文件会保留在工作区</span>$ <span class="token function">git</span> <span class="token function">rm</span> --cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 改名文件，并且将这个改名放入暂存区</span>$ <span class="token function">git</span> <span class="token function">mv</span> <span class="token punctuation">[</span>file-original<span class="token punctuation">]</span> <span class="token punctuation">[</span>file-renamed<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4、提交代码"><a href="#4、提交代码" class="headerlink" title="4、提交代码"></a>4、提交代码</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 提交暂存区到仓库区</span>$ <span class="token function">git</span> commit -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交暂存区的指定文件到仓库区</span>$ <span class="token function">git</span> commit <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>. -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交工作区自上次commit之后的变化，直接到仓库区</span>$ <span class="token function">git</span> commit -a<span class="token comment" spellcheck="true"># 提交时显示所有diff信息</span>$ <span class="token function">git</span> commit -v<span class="token comment" spellcheck="true"># 使用一次新的commit，替代上一次提交</span><span class="token comment" spellcheck="true"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span>$ <span class="token function">git</span> commit --amend -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重做上一次commit，并包括指定文件的新变化</span>$ <span class="token function">git</span> commit --amend <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5、操作分支"><a href="#5、操作分支" class="headerlink" title="5、操作分支"></a>5、操作分支</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有本地分支</span>$ <span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 列出所有远程分支</span>$ <span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 列出所有本地分支和远程分支</span>$ <span class="token function">git</span> branch -a<span class="token comment" spellcheck="true"># 新建一个分支，但依然停留在当前分支</span>$ <span class="token function">git</span> branch <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 以远程分支为基础新建一个分支，并切换到该分支</span>$ <span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> origin/<span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，指向指定commit</span>$ <span class="token function">git</span> branch <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，与指定的远程分支建立追踪关系</span>$ <span class="token function">git</span> branch --track <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换到指定分支，并更新工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换到上一个分支</span>$ <span class="token function">git</span> checkout -<span class="token comment" spellcheck="true"># 建立追踪关系，在现有分支与指定的远程分支之间</span>$ <span class="token function">git</span> branch --set-upstream <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并指定分支到当前分支</span>$ <span class="token function">git</span> merge <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 选择一个commit，合并进当前分支</span>$ <span class="token function">git</span> cherry-pick <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除分支</span>$ <span class="token function">git</span> branch -d <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除远程分支</span>$ <span class="token function">git</span> push origin --delete <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span>$ <span class="token function">git</span> branch -dr <span class="token punctuation">[</span>remote/branch<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6、操作标签"><a href="#6、操作标签" class="headerlink" title="6、操作标签"></a>6、操作标签</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有tag</span>$ <span class="token function">git</span> tag<span class="token comment" spellcheck="true"># 新建一个tag在当前commit</span>$ <span class="token function">git</span> tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个tag在指定commit</span>$ <span class="token function">git</span> tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除本地tag</span>$ <span class="token function">git</span> tag -d <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除远程tag</span>$ <span class="token function">git</span> push origin :refs/tags/<span class="token punctuation">[</span>tagName<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 查看tag信息</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交指定tag</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交所有tag</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --tags<span class="token comment" spellcheck="true"># 新建一个分支，指向某个tag</span>$ <span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7、查看信息"><a href="#7、查看信息" class="headerlink" title="7、查看信息"></a>7、查看信息</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示有变更的文件</span>$ <span class="token function">git</span> status<span class="token comment" spellcheck="true"># 显示当前分支的版本历史</span>$ <span class="token function">git</span> log<span class="token comment" spellcheck="true"># 显示commit历史，以及每次commit发生变更的文件</span>$ <span class="token function">git</span> log --stat<span class="token comment" spellcheck="true"># 搜索提交历史，根据关键词</span>$ <span class="token function">git</span> log -S <span class="token punctuation">[</span>keyword<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某个commit之后的所有变动，每个commit占据一行</span>$ <span class="token function">git</span> log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD --pretty<span class="token operator">=</span>format:%s<span class="token comment" spellcheck="true"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span>$ <span class="token function">git</span> log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD --grep feature<span class="token comment" spellcheck="true"># 显示某个文件的版本历史，包括文件改名</span>$ <span class="token function">git</span> log --follow <span class="token punctuation">[</span>file<span class="token punctuation">]</span>$ <span class="token function">git</span> whatchanged <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示指定文件相关的每一次diff</span>$ <span class="token function">git</span> log -p <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示过去5次提交</span>$ <span class="token function">git</span> log -5 --pretty --oneline<span class="token comment" spellcheck="true"># 显示所有提交过的用户，按提交次数排序</span>$ <span class="token function">git</span> shortlog -sn<span class="token comment" spellcheck="true"># 显示指定文件是什么人在什么时间修改过</span>$ <span class="token function">git</span> blame <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示暂存区和工作区的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span><span class="token comment" spellcheck="true"># 显示暂存区和上一个commit的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> --cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示工作区与当前分支最新commit之间的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> HEAD<span class="token comment" spellcheck="true"># 显示两次提交之间的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token punctuation">[</span>first-branch<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token punctuation">[</span>second-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示今天你写了多少行代码</span>$ <span class="token function">git</span> <span class="token function">diff</span> --shortstat <span class="token string">"@{0 day ago}"</span><span class="token comment" spellcheck="true"># 显示某次提交的元数据和内容变化</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某次提交发生变化的文件</span>$ <span class="token function">git</span> show --name-only <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某次提交时，某个文件的内容</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>:<span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示当前分支的最近几次提交</span>$ <span class="token function">git</span> reflog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8、远程同步"><a href="#8、远程同步" class="headerlink" title="8、远程同步"></a>8、远程同步</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载远程仓库的所有变动</span>$ <span class="token function">git</span> fetch <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示所有远程仓库</span>$ <span class="token function">git</span> remote -v<span class="token comment" spellcheck="true"># 显示某个远程仓库的信息</span>$ <span class="token function">git</span> remote show <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 增加一个新的远程仓库，并命名</span>$ <span class="token function">git</span> remote add <span class="token punctuation">[</span>shortname<span class="token punctuation">]</span> <span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 取回远程仓库的变化，并与本地分支合并</span>$ <span class="token function">git</span> pull <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 上传本地指定分支到远程仓库</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 强行推送当前分支到远程仓库，即使有冲突</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --force<span class="token comment" spellcheck="true"># 推送所有分支到远程仓库</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9、撤销修改"><a href="#9、撤销修改" class="headerlink" title="9、撤销修改"></a>9、撤销修改</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 恢复暂存区的指定文件到工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 恢复某个commit的指定文件到暂存区和工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>commit<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 恢复暂存区的所有文件到工作区</span>$ <span class="token function">git</span> checkout <span class="token keyword">.</span><span class="token comment" spellcheck="true"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span>$ <span class="token function">git</span> reset <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置暂存区与工作区，与上一次commit保持一致</span>$ <span class="token function">git</span> reset --hard<span class="token comment" spellcheck="true"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span>$ <span class="token function">git</span> reset <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span>$ <span class="token function">git</span> reset --hard <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span>$ <span class="token function">git</span> reset --keep <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个commit，用来撤销指定commit</span><span class="token comment" spellcheck="true"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span>$ <span class="token function">git</span> revert <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 暂时将未提交的变化移除，稍后再移入</span>$ <span class="token function">git</span> stash$ <span class="token function">git</span> stash pop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="10、其他命令"><a href="#10、其他命令" class="headerlink" title="10、其他命令"></a>10、其他命令</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 生成一个可供发布的压缩包</span>$ <span class="token function">git</span> archive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="三、Git分支管理策略"><a href="#三、Git分支管理策略" class="headerlink" title="三、Git分支管理策略"></a>三、Git分支管理策略</h3><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring面试题</title>
      <link href="/posts/8791.html"/>
      <url>/posts/8791.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、Spring是什么"><a href="#1、Spring是什么" class="headerlink" title="1、Spring是什么?"></a>1、Spring是什么?</h3><p>Spring是一个轻量级的IOC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置。</p><p>主要由以下几个模块组成：</p><p><strong>Spring Core</strong>：核心类库，提供IOC服务；</p><p><strong>Spring Context</strong>：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</p><p><strong>Spring AOP</strong>：AOP服务；</p><p><strong>Spring DAO</strong>：对JDBC的抽象，简化了数据访问异常的处理；</p><p><strong>Spring ORM</strong>：对现有的ORM框架的支持；</p><p><strong>Spring Web</strong>：提供了基本的面向Web的综合特性，例如多文件上传；</p><p><strong>Spring MVC</strong>：提供面向Web应用的Model-View-Controller实现。</p><h3 id="2、Spring-的优点？"><a href="#2、Spring-的优点？" class="headerlink" title="2、Spring 的优点？"></a>2、Spring 的优点？</h3><p>（1）Spring属于低侵入式设计，代码的污染极低；</p><p>（2）Spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</p><p>（3）Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用；</p><p>（4）Spring对于主流的应用框架提供了集成支持。</p><h3 id="3、Spring的AOP理解"><a href="#3、Spring的AOP理解" class="headerlink" title="3、Spring的AOP理解"></a>3、Spring的AOP理解</h3><p><strong>OOP</strong>称为面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p><strong>AOP</strong>称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等场景。</p><p>AOP实现的关键在于<strong>代理模式</strong>，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p><p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><p>① JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,  生成目标类的代理对象。</p><p>② 如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p><p>（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p><p> InvocationHandler 的 invoke(Object  proxy,Method  method,Object[] args)：proxy是最终生成的代理实例;  method 是被代理目标实例的某个具体方法;  args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p><h3 id="4、Spring的IOC理解"><a href="#4、Spring的IOC理解" class="headerlink" title="4、Spring的IOC理解?"></a>4、Spring的IOC理解?</h3><p>（1）IOC就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</p><p>（2）最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p><p>（3）Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。</p><p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p><h3 id="5、BeanFactory和ApplicationContext有什么区别？"><a href="#5、BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="5、BeanFactory和ApplicationContext有什么区别？"></a>5、BeanFactory和ApplicationContext有什么区别？</h3><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><p>（1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><p>①继承MessageSource，因此支持国际化。</p><p>②统一的资源文件访问方式。</p><p>③提供在监听器中注册bean的事件。</p><p>④同时加载多个配置文件。</p><p>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p><p>（2）①BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><p>②ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p><p>③相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p><p>（3）BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p><p>（4）BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><h3 id="6、请解释Spring-Bean的生命周期？"><a href="#6、请解释Spring-Bean的生命周期？" class="headerlink" title="6、请解释Spring Bean的生命周期？"></a>6、请解释Spring Bean的生命周期？</h3><p> 首先说一下Servlet的生命周期：实例化，初始init，接收请求service，销毁destroy；</p><p> Spring上下文中的Bean生命周期也类似，如下：</p><p>（1）<strong>实例化Bean</strong></p><p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p><p>（2）<strong>设置对象属性（依赖注入）</strong></p><p>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><p>（3）<strong>处理Aware接口</strong></p><p>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：</p><p>①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；</p><p>②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。</p><p>③如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文；</p><p>（4）<strong>BeanPostProcessor</strong></p><p>如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p><p>（5）<strong>InitializingBean 与 init-method</strong></p><p>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p><p>（6）<strong>调用postProcessAfterInitialization</strong></p><p>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p><p>以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</p><p>（7）<strong>DisposableBean</strong></p><p>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p><p>（8）<strong>destroy-method</strong></p><p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p><h3 id="7、-解释Spring支持的几种bean的作用域？"><a href="#7、-解释Spring支持的几种bean的作用域？" class="headerlink" title="7、 解释Spring支持的几种bean的作用域？"></a>7、 解释Spring支持的几种bean的作用域？</h3><p>Spring容器中的bean可以分为5个范围：</p><p>（1）<strong>singleton</strong>：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。</p><p>（2）<strong>prototype</strong>：为每一个bean请求提供一个实例。</p><p>（3）<strong>request</strong>：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</p><p>（4）<strong>session</strong>：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</p><p>（5）<strong>global-session</strong>：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</p><h3 id="8、Spring框架中的单例Beans是线程安全的么？"><a href="#8、Spring框架中的单例Beans是线程安全的么？" class="headerlink" title="8、Spring框架中的单例Beans是线程安全的么？"></a>8、Spring框架中的单例Beans是线程安全的么？</h3><p> Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</p><h3 id="9、Spring如何处理线程并发问题？"><a href="#9、Spring如何处理线程并发问题？" class="headerlink" title="9、Spring如何处理线程并发问题？"></a>9、Spring如何处理线程并发问题？</h3><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p><p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p><p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><h3 id="10-1、Spring基于xml注入bean的几种方式？"><a href="#10-1、Spring基于xml注入bean的几种方式？" class="headerlink" title="10-1、Spring基于xml注入bean的几种方式？"></a>10-1、Spring基于xml注入bean的几种方式？</h3><p>（1）Set方法注入；</p><p>（2）构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</p><p>（3）静态工厂注入；</p><p>（4）实例工厂；</p><p>详细内容可以阅读：<a href="https://blog.csdn.net/a745233700/article/details/89307518" target="_blank" rel="noopener">https://blog.csdn.net/a745233700/article/details/89307518</a></p><h3 id="10-2、Spring的自动装配："><a href="#10-2、Spring的自动装配：" class="headerlink" title="10-2、Spring的自动装配："></a>10-2、Spring的自动装配：</h3><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p><p>在Spring框架xml配置中共有5种自动装配：</p><p>（1）no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</p><p>（2）byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。 </p><p>（3）byType：通过参数的数据类型进行自动装配。</p><p>（4）constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p><p>（5）autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p><p>基于注解的方式：</p><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</p><p>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p><p>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</p><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>注：@Autowired和@Resource之间的区别</p><p>(1) @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p><p>(2) @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p><h3 id="11、Spring-框架中都用到了哪些设计模式？"><a href="#11、Spring-框架中都用到了哪些设计模式？" class="headerlink" title="11、Spring 框架中都用到了哪些设计模式？"></a>11、Spring 框架中都用到了哪些设计模式？</h3><p>（1）<strong>工厂模式</strong>：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p><p>（2）<strong>单例模式</strong>：Bean默认为单例模式。</p><p>（3）<strong>代理模式</strong>：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p><p>（4）<strong>模板方法</strong>：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p><p>（5）<strong>观察者模式</strong>：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p><h3 id="12、Spring事务的实现方式和实现原理？"><a href="#12、Spring事务的实现方式和实现原理？" class="headerlink" title="12、Spring事务的实现方式和实现原理？"></a>12、Spring事务的实现方式和实现原理？</h3><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p><h4 id="（1）Spring事务的种类："><a href="#（1）Spring事务的种类：" class="headerlink" title="（1）Spring事务的种类："></a>（1）Spring事务的种类：</h4><p>spring支持编程式事务管理和声明式事务管理两种方式：</p><p>①编程式事务管理使用TransactionTemplate。</p><p>②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><p>声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。</p><p>声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式，使业务代码不受污染，只要加上注解就可以获得完全的事务支持。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p><h4 id="（2）spring的事务传播行为："><a href="#（2）spring的事务传播行为：" class="headerlink" title="（2）spring的事务传播行为："></a>（2）spring的事务传播行为：</h4><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘</p><p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p><p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p><p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p><h4 id="（3）Spring中的隔离级别："><a href="#（3）Spring中的隔离级别：" class="headerlink" title="（3）Spring中的隔离级别："></a>（3）Spring中的隔离级别：</h4><p>① ISOLATION_DEFAULT：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。</p><p>② ISOLATION_READ_UNCOMMITTED：读未提交，允许另外一个事务可以看到这个事务未提交的数据。</p><p>③ ISOLATION_READ_COMMITTED：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。</p><p>④ ISOLATION_REPEATABLE_READ：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。</p><p>⑤ ISOLATION_SERIALIZABLE：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。</p><h3 id="13、Spring框架中有哪些不同类型的事件？"><a href="#13、Spring框架中有哪些不同类型的事件？" class="headerlink" title="13、Spring框架中有哪些不同类型的事件？"></a>13、Spring框架中有哪些不同类型的事件？</h3><p>Spring 提供了以下5种标准的事件：</p><p>（1）上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</p><p>（2）上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</p><p>（3）上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</p><p>（4）上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</p><p>（5）请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</p><p>如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p><h3 id="14、解释一下Spring-AOP里面的几个名词："><a href="#14、解释一下Spring-AOP里面的几个名词：" class="headerlink" title="14、解释一下Spring AOP里面的几个名词："></a>14、解释一下Spring AOP里面的几个名词：</h3><p>（1）Aspect：切面，由一系列切点、增强和引入组成的模块对象，可定义优先级，从而影响增强和引入的执行顺序。事务管理（Transaction management）在java企业应用中就是一个很好的切面样例。</p><p>（2）Join point：接入点，程序执行期的一个点，例如方法执行、类初始化、异常处理。 在Spring AOP中，接入点始终表示方法执行。</p><p>（3）Advice：增强，切面在特定接入点的执行动作，包括 “around,” “before” and “after”等多种类型。包含Spring在内的许多AOP框架，通常会使用拦截器来实现增强，围绕着接入点维护着一个拦截器链。</p><p>（4）Pointcut：切点，用来匹配特定接入点的谓词（表达式），增强将会与切点表达式产生关联，并运行在任何切点匹配到的接入点上。通过切点表达式匹配接入点是AOP的核心，Spring默认使用AspectJ的切点表达式。</p><p>（5）Introduction：引入，为某个type声明额外的方法和字段。Spring AOP允许你引入任何接口以及它的默认实现到被增强对象上。</p><p>（6）Target object：目标对象，被一个或多个切面增强的对象。也叫作被增强对象。既然Spring AOP使用运行时代理（runtime proxies），那么目标对象就总是代理对象。</p><p>（7）AOP proxy：AOP代理，为了实现切面功能一个对象会被AOP框架创建出来。在Spring框架中AOP代理的默认方式是：有接口，就使用基于接口的JDK动态代理，否则使用基于类的CGLIB动态代理。但是我们可以通过设置proxy-target-class=”true”，完全使用CGLIB动态代理。</p><p>（8）Weaving：织入，将一个或多个切面与类或对象链接在一起创建一个被增强对象。织入能发生在编译时 （compile time ）(使用AspectJ编译器)，加载时（load time），或运行时（runtime） 。Spring AOP默认就是运行时织入，可以通过枚举AdviceMode来设置。</p><p>（1）<strong>切面（Aspect）</strong>：被抽取的公共模块，可能会横切多个对象。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p><p>（2）<strong>连接点（Join point）</strong>：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 </p><p>（3）<strong>通知（Advice）</strong>：在切面的某个特定的连接点（Join point）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。</p><p>（4）<strong>切入点（Pointcut）</strong>：切入点是指 我们要对哪些Join point进行拦截的定义。通过切入点表达式，指定拦截的方法，比如指定拦截add<em>、search</em>。</p><p>（5）<strong>引入（Introduction）</strong>：（也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。</p><p>（6）<strong>目标对象（Target Object）</strong>： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p><p>（7）<strong>织入（Weaving）</strong>：指把增强应用到目标对象来创建新的代理对象的过程。Spring是在运行时完成织入。</p><p>切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</p><h3 id="15、Spring通知类型有哪些？"><a href="#15、Spring通知类型有哪些？" class="headerlink" title="15、Spring通知类型有哪些？"></a>15、Spring通知类型有哪些？</h3><p><a href="https://blog.csdn.net/qq_32331073/article/details/80596084" target="_blank" rel="noopener">https://blog.csdn.net/qq_32331073/article/details/80596084</a></p><p>（1）<strong>前置通知（Before advice）</strong>：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</p><p>（2）<strong>返回后通知（After returning advice）</strong>：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。 </p><p>（3）<strong>抛出异常后通知（After throwing advice）</strong>：在方法抛出异常退出时执行的通知。 </p><p>（4）<strong>后置通知（After (finally) advice）</strong>：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 </p><p>（5）<strong>环绕通知（Around Advice）</strong>：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。 环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。 </p><p>同一个aspect，不同advice的执行顺序：</p><p>①没有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning</p><p>②有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生</p><p>advice执行顺序中，有异常的情况执行顺序 around after advice 是不会执行的 正确的顺序是： </p><p>1.around before </p><p>2.before </p><p>3.target method execution </p><p>4.after </p><p>5.afterthrowing</p><p>6.throw exception</p><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis面试题</title>
      <link href="/posts/44b0.html"/>
      <url>/posts/44b0.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、什么是Mybatis"><a href="#1、什么是Mybatis" class="headerlink" title="1、什么是Mybatis"></a>1、什么是Mybatis</h3><p>（1）Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</p><p>（2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p><p>（3）通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</p><h3 id="2、Mybaits的优点"><a href="#2、Mybaits的优点" class="headerlink" title="2、Mybaits的优点"></a>2、Mybaits的优点</h3><p>（1）基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</p><p>（2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p><p>（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p><p>（4）能够与Spring很好的集成；</p><p>（5）提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p><h3 id="3、MyBatis的缺点"><a href="#3、MyBatis的缺点" class="headerlink" title="3、MyBatis的缺点"></a>3、MyBatis的缺点</h3><p>（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p><p>（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><h3 id="4、MyBatis框架适合什么场合使用？"><a href="#4、MyBatis框架适合什么场合使用？" class="headerlink" title="4、MyBatis框架适合什么场合使用？"></a>4、MyBatis框架适合什么场合使用？</h3><p>（1）MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</p><p>（2）对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</p><h3 id="5、MyBatis与Hibernate有哪些不同？"><a href="#5、MyBatis与Hibernate有哪些不同？" class="headerlink" title="5、MyBatis与Hibernate有哪些不同？"></a>5、MyBatis与Hibernate有哪些不同？</h3><p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要开发人员自己编写Sql语句。</p><p>（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 </p><p>（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。 </p><h3 id="6、-和-的区别是什么？"><a href="#6、-和-的区别是什么？" class="headerlink" title="6、#{}和${}的区别是什么？"></a>6、#{}和${}的区别是什么？</h3><p>（1）{}是预编译处理，${}是字符串替换；</p><p>（2）Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p><p>（3）Mybatis在处理{}时，就是把{}替换成变量的值；</p><p>（4）使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h3 id="7、当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#7、当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="7、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a>7、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h3><p>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span>”selectorder”</span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span>”int”</span> <span class="token attr-name">resulteType</span><span class="token attr-value"><span class="token punctuation">=</span>”me.gacl.domain.order”</span><span class="token punctuation">></span></span>   select order_id id, order_no orderno ,order_price price form orders where order_id=#{id};<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第2种： 通过<resultmap>来映射字段名和实体类属性名的一一对应的关系。</resultmap></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getOrder<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>orderresultmap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   select * from orders where order_id=#{id}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>me.gacl.domain.order<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>orderresultmap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--用id属性来映射主键字段--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>order_id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性--></span>    &lt;result property = “orderno" column = ”order_no"/>    &lt;result property = "price" column = "order_price" /><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>reslutMap</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8、-模糊查询like语句该怎么写"><a href="#8、-模糊查询like语句该怎么写" class="headerlink" title="8、 模糊查询like语句该怎么写?"></a>8、 模糊查询like语句该怎么写?</h3><p>第1种：在Java代码中添加sql通配符</p><p>Java</p><pre class="line-numbers language-java"><code class="language-java">String wildcardname <span class="token operator">=</span> “<span class="token operator">%</span>smi<span class="token operator">%</span>”<span class="token punctuation">;</span>List<span class="token operator">&lt;</span>name<span class="token operator">></span> names <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">selectlike</span><span class="token punctuation">(</span>wildcardname<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span>”selectlike”</span><span class="token punctuation">></span></span> select * from foo where bar like #{value,jdbcType=VARCHAR}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第2种：在sql语句中拼接通配符，会引起sql注入</p><p>Java</p><pre class="line-numbers language-java"><code class="language-java">String wildcardname <span class="token operator">=</span> “smi”<span class="token punctuation">;</span>List<span class="token operator">&lt;</span>name<span class="token operator">></span> names <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">selectlike</span><span class="token punctuation">(</span>wildcardname<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span>”selectlike”</span><span class="token punctuation">></span></span>     select * from foo where bar like LIKE CONCAT('%', #{value,jdbcType=VARCHAR}, '%')<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="9、通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#9、通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="9、通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>9、通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h3><p>Dao接口即Mapper接口。接口的全限名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。</p><p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。在Mybatis中，每一个select、insert、update、delete标签，都会被解析为一个MapperStatement对象。</p><p>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面 id 为 findStudentById 的 MapperStatement。</p><p>Mapper接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回。</p><h3 id="10、Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#10、Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="10、Mybatis是如何进行分页的？分页插件的原理是什么？"></a>10、Mybatis是如何进行分页的？分页插件的原理是什么？</h3><p>Mybatis使用<strong>RowBounds</strong>对象进行分页，它是针对ResultSet结果集执行的内存分页，而<strong>非物理分页</strong>。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><h3 id="11、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#11、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="11、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>11、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><p>（1）使用<resultmap>标签，逐一定义数据库列名和对象属性名之间的映射关系。</resultmap></p><p>（2）使用sql列的别名功能，将列的别名书写为对象属性名。</p><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h3 id="12、如何执行批量插入"><a href="#12、如何执行批量插入" class="headerlink" title="12、如何执行批量插入?"></a>12、如何执行批量插入?</h3><p>创建一个简单的insert语句:</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span>”insertname”</span><span class="token punctuation">></span></span>     insert into names (name) values (#{value})<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后在java代码中像下面这样执行批处理插入:</p><pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>“fred”<span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>“barney”<span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>“betty”<span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>“wilma”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 注意这里 executorType.batch</span>SqlSession sqlSession <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span>executorType<span class="token punctuation">.</span>batch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span> NameMapper mapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>NameMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>string name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{</span>     mapper<span class="token punctuation">.</span><span class="token function">insertname</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> sqlSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span> e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> sqlSession<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">throw</span> e<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>     sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13、如何获取自动生成的-主-键值"><a href="#13、如何获取自动生成的-主-键值" class="headerlink" title="13、如何获取自动生成的(主)键值?"></a>13、如何获取自动生成的(主)键值?</h3><p>insert 方法总是返回一个int值 ，这个值代表的是插入的行数。</p><p>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。</p><p>示例：</p><p>Xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertName<span class="token punctuation">"</span></span> <span class="token attr-name">useGeneratedKeys</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     insert into names (name) values (#{name})<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Java</p><pre class="line-numbers language-java"><code class="language-java">Name name <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>name<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>“fred”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> rows <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">insertName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 完成后,id已经被设置到对象中</span>system<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“rows inserted <span class="token operator">=</span> ” <span class="token operator">+</span> rows<span class="token punctuation">)</span><span class="token punctuation">;</span>system<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“generated key value <span class="token operator">=</span> ” <span class="token operator">+</span> name<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="14、在mapper中如何传递多个参数"><a href="#14、在mapper中如何传递多个参数" class="headerlink" title="14、在mapper中如何传递多个参数?"></a>14、在mapper中如何传递多个参数?</h3><p>（1）第一种：<br>DAO层的函数</p><pre class="line-numbers language-java"><code class="language-java">Public User <span class="token function">selectUser</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String area<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对应的xml,#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。</p><pre class="line-numbers language-xml"><code class="language-xml">&lt;select id="selectUser"resultMap="BaseResultMap">      select * fromuser_user_t whereuser_name = #{0} anduser_area=#{1}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（2）第二种： 使用 @param 注解:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>   user <span class="token function">selectuser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@param</span><span class="token punctuation">(</span>“username”<span class="token punctuation">)</span> String username<span class="token punctuation">,</span><span class="token annotation punctuation">@param</span><span class="token punctuation">(</span>“hashedpassword”<span class="token punctuation">)</span> String hashedpassword<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper):</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span>”selectuser”</span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span>”user”</span><span class="token punctuation">></span></span>      select id, username, hashedpassword      from some_table      where username = #{username}      and hashedpassword = #{hashedpassword}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）第三种：多个参数封装成map</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL</span><span class="token comment" spellcheck="true">//由于我们的参数超过了两个，而方法中只有一个Object参数收集，因此我们使用Map集合来装载我们的参数</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>     map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> sqlSession<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span><span class="token string">"StudentID.pagination"</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>     e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     sqlSession<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> e<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">finally</span><span class="token punctuation">{</span>         MybatisUtil<span class="token punctuation">.</span><span class="token function">closeSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="15、Mybatis动态sql有什么用？执行原理？有哪些动态sql？"><a href="#15、Mybatis动态sql有什么用？执行原理？有哪些动态sql？" class="headerlink" title="15、Mybatis动态sql有什么用？执行原理？有哪些动态sql？"></a>15、Mybatis动态sql有什么用？执行原理？有哪些动态sql？</h3><p>Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接sql的功能。</p><p>Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind</p><h3 id="16、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#16、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="16、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>16、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h3><p><resultmap>、<parametermap>、<sql>、<include>、<selectkey>，加上动态sql的9个标签，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectkey>为不支持自增的主键生成策略标签。</selectkey></include></sql></selectkey></include></sql></parametermap></resultmap></p><h3 id="17、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#17、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="17、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>17、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h3><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；</p><p>原因就是namespace+id是作为Map&lt;String, MapperStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><p>但是，在以前的Mybatis版本的namespace是可选的，不过新版本的namespace已经是必须的了。</p><h3 id="18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h3 id="19、-一对一、一对多的关联查询-？"><a href="#19、-一对一、一对多的关联查询-？" class="headerlink" title="19、 一对一、一对多的关联查询 ？"></a>19、 一对一、一对多的关联查询 ？</h3><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.lcb.mapping.userMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--association  一对一关联查询 --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getClass<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ClassesResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          select * from class c, teacher t where c.teacher_id = t.t_id and c.c_id = #{id}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.lcb.user.Classes<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ClassesResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token comment" spellcheck="true">&lt;!-- 实体类的字段名和数据表的字段名映射 --></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>c_id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>c_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 一个老师 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.lcb.user.Teacher<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>t_id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>t_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>     <span class="token comment" spellcheck="true">&lt;!--collection  一对多关联查询 --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getClass2<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ClassesResultMap2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#{id}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.lcb.user.Classes<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ClassesResultMap2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>c_id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>c_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>          <span class="token comment" spellcheck="true">&lt;!-- 一个老师 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.lcb.user.Teacher<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>t_id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>t_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span>                  <span class="token comment" spellcheck="true">&lt;!-- 多个学生 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.lcb.user.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>s_id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>s_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="20、MyBatis实现一对一有几种方式"><a href="#20、MyBatis实现一对一有几种方式" class="headerlink" title="20、MyBatis实现一对一有几种方式?"></a>20、MyBatis实现一对一有几种方式?</h3><p>有联合查询和嵌套查询两种方式</p><p>（1）联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；</p><p>（2）嵌套查询是先查一个表，根据这个表里面的结果的 外键id，去再另外一个表里面查询数据,也是通过association配置，但另外一个表的查询通过select属性配置。</p><h3 id="21、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#21、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="21、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>21、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><h3 id="22、Mybatis的一级、二级缓存"><a href="#22、Mybatis的一级、二级缓存" class="headerlink" title="22、Mybatis的一级、二级缓存"></a>22、Mybatis的一级、二级缓存</h3><p>（1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p><p>（2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache> ；</cache></p><p>（3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear 掉并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p><h3 id="23、什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#23、什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="23、什么是MyBatis的接口绑定？有哪些实现方式？"></a>23、什么是MyBatis的接口绑定？有哪些实现方式？</h3><p>接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p><p>接口绑定有两种实现方式,</p><p>一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；另外一种就是通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。</p><p>当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。</p><h3 id="24、使用MyBatis的mapper接口调用时有哪些要求？"><a href="#24、使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="24、使用MyBatis的mapper接口调用时有哪些要求？"></a>24、使用MyBatis的mapper接口调用时有哪些要求？</h3><p>①  Mapper接口方法名和mapper.xml中定义的每个sql的id相同；<br>②  Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；<br>③  Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；<br>④  Mapper.xml文件中的namespace即是mapper接口的类路径。</p><h3 id="25、Mapper编写有哪几种方式？"><a href="#25、Mapper编写有哪几种方式？" class="headerlink" title="25、Mapper编写有哪几种方式？"></a>25、Mapper编写有哪几种方式？</h3><p>第一种：接口实现类继承SqlSessionDaoSupport：使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件。<br>（1）在sqlMapConfig.xml中配置mapper.xml的位置</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapper.xml文件的地址<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapper.xml文件的地址<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（2）定义mapper接口<br>（3）实现类集成SqlSessionDaoSupport<br>mapper方法中可以this.getSqlSession()进行数据增删改查。<br>（4）spring 配置</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span> <span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapper接口的实现<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第二种：使用org.mybatis.spring.mapper.MapperFactoryBean：<br>（1）在sqlMapConfig.xml中配置mapper.xml的位置，如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapper.xml文件的地址<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapper.xml文件的地址<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（2）定义mapper接口：<br>①mapper.xml中的namespace为mapper接口的地址<br>②mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致<br>③Spring中定义</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.spring.mapper.MapperFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapperInterface<span class="token punctuation">"</span></span>   <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapper接口地址<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第三种：使用mapper扫描器：<br>（1）mapper.xml文件编写：<br>mapper.xml中的namespace为mapper接口的地址；<br>mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致；<br>如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置。<br>（2）定义mapper接口：<br>注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录<br>（3）配置mapper扫描器：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.spring.mapper.MapperScannerConfigurer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>basePackage<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapper接口包地址<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactoryBeanName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（4）使用扫描器后从spring容器中获取mapper的实现对象。</p><h3 id="26、简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#26、简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="26、简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>26、简述Mybatis的插件运行原理，以及如何编写一个插件。</h3><p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>编写插件：实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【代码】——用户信息脱敏处理</title>
      <link href="/posts/ef38.html"/>
      <url>/posts/ef38.html</url>
      
        <content type="html"><![CDATA[<p>对用户的姓名、电话号码、邮箱、身份证等信息进行脱敏处理。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"regexp"</span>    <span class="token string">"strings"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 匹配 手机号,邮箱,中文,身份证等等 进行脱敏处理</span><span class="token keyword">func</span> <span class="token function">HideStar</span><span class="token punctuation">(</span>str <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>result <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> str <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"***"</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">"@"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 邮箱</span>        res <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">"@"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3</span> <span class="token punctuation">{</span>            resString <span class="token operator">:=</span> <span class="token string">"***"</span>            result <span class="token operator">=</span> resString <span class="token operator">+</span> <span class="token string">"@"</span> <span class="token operator">+</span> res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            res2 <span class="token operator">:=</span> <span class="token function">Substr2</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>            resString <span class="token operator">:=</span> res2 <span class="token operator">+</span> <span class="token string">"***"</span>            result <span class="token operator">=</span> resString <span class="token operator">+</span> <span class="token string">"@"</span> <span class="token operator">+</span> res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        reg <span class="token operator">:=</span> <span class="token string">`^1[0-9]\d{9}$`</span>        rgx <span class="token operator">:=</span> regexp<span class="token punctuation">.</span><span class="token function">MustCompile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span>        mobileMatch <span class="token operator">:=</span> rgx<span class="token punctuation">.</span><span class="token function">MatchString</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>        <span class="token keyword">if</span> mobileMatch <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 手机号</span>            result <span class="token operator">=</span> <span class="token function">Substr2</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"****"</span> <span class="token operator">+</span> <span class="token function">Substr2</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            nameRune <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>            lens <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>nameRune<span class="token punctuation">)</span>            <span class="token keyword">if</span> lens <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> <span class="token string">"***"</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> lens <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>nameRune<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"*"</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> lens <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>nameRune<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"*"</span> <span class="token operator">+</span> <span class="token function">string</span><span class="token punctuation">(</span>nameRune<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> lens <span class="token operator">==</span> <span class="token number">4</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>nameRune<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"**"</span> <span class="token operator">+</span> <span class="token function">string</span><span class="token punctuation">(</span>nameRune<span class="token punctuation">[</span>lens<span class="token number">-1</span><span class="token punctuation">:</span>lens<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> lens <span class="token operator">></span> <span class="token number">4</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>nameRune<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"***"</span> <span class="token operator">+</span> <span class="token function">string</span><span class="token punctuation">(</span>nameRune<span class="token punctuation">[</span>lens<span class="token number">-2</span><span class="token punctuation">:</span>lens<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">Substr2</span><span class="token punctuation">(</span>str <span class="token builtin">string</span><span class="token punctuation">,</span> start <span class="token builtin">int</span><span class="token punctuation">,</span> end <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    rs <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>rs<span class="token punctuation">[</span>start<span class="token punctuation">:</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"testing"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 脱敏测试</span><span class="token keyword">func</span> <span class="token function">TestStar</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 邮箱</span>    result <span class="token operator">:=</span> <span class="token function">HideStar</span><span class="token punctuation">(</span><span class="token string">"1511X2456@qq.com"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 151***@qq.com</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 电话号码</span>    result <span class="token operator">=</span> <span class="token function">HideStar</span><span class="token punctuation">(</span><span class="token string">"13077881053"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 130****1053</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 身份证</span>    result <span class="token operator">=</span> <span class="token function">HideStar</span><span class="token punctuation">(</span><span class="token string">"362201200005302565"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 36***15</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 姓名</span>    result <span class="token operator">=</span> <span class="token function">HideStar</span><span class="token punctuation">(</span><span class="token string">"小叮当"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 小*当</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【排序算法】——插入排序</title>
      <link href="/posts/15fb.html"/>
      <url>/posts/15fb.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 冒泡排序 * * 原理描述：比较相邻两个元素大小，进行交换，将大（小）的元素放到右边，以此类推，直到排序完毕。 * * 平均时间复杂度 O(n^2) 空间复杂度 O(1) 稳定 * * @param array 数组 * @return int[] */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> array<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 没有数据交换提前退出循环</span>    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程面试题</title>
      <link href="/posts/2ec7.html"/>
      <url>/posts/2ec7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/cmyperson/article/details/79610870" target="_blank" rel="noopener">https://blog.csdn.net/cmyperson/article/details/79610870</a></p></blockquote><p>目录：</p><ol><li>什么是线程？</li><li>什么是线程安全和线程不安全？</li><li>什么是自旋锁？</li><li>什么是Java内存模型？</li><li>什么是CAS？</li><li>什么是乐观锁和悲观锁？</li><li>什么是AQS？</li><li>什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</li><li>什么是Executors框架？</li><li>什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</li><li>什么是Callable和Future?</li><li>什么是FutureTask?</li><li>什么是同步容器和并发容器的实现？</li><li>什么是多线程？优缺点？</li><li>什么是多线程的上下文切换？</li><li>ThreadLocal的设计理念与作用？</li><li>ThreadPool（线程池）用法与优势？</li><li>Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。</li><li>synchronized和ReentrantLock的区别？</li><li>Semaphore有什么作用？</li><li>Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</li><li>Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</li><li>ConcurrentHashMap的并发度是什么？</li><li>ReentrantReadWriteLock读写锁的使用？</li><li>CyclicBarrier和CountDownLatch的用法及区别？</li><li>LockSupport工具？</li><li>Condition接口及其实现原理？</li><li>Fork/Join框架的理解?</li><li>wait()和sleep()的区别?</li><li>线程的五个状态（五种状态，创建、就绪、运行、阻塞和死亡）?</li><li>start()方法和run()方法的区别？</li><li>Runnable接口和Callable接口的区别？</li><li>volatile关键字的作用？</li><li>Java中如何获取到线程dump文件？</li><li>线程和进程有什么区别？</li><li>线程实现的方式有几种（四种）？</li><li>高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</li><li>如果你提交任务时，线程池队列已满，这时会发生什么？</li><li>锁的等级：方法锁、对象锁、类锁?</li><li>如果同步块内的线程抛出异常会发生什么？</li><li>并发编程（concurrency）并行编程（parallellism）有什么区别？</li><li>如何保证多线程下 i++ 结果正确？</li><li>一个线程如果出现了运行时异常会怎么样?</li><li>如何在两个线程之间共享数据?</li><li>生产者消费者模型的作用是什么?</li><li>怎么唤醒一个阻塞的线程?</li><li>Java中用到的线程调度算法是什么</li><li>单例模式的线程安全性?</li><li>线程类的构造方法、静态块是被哪个线程调用的?</li><li>同步方法和同步块，哪个是更好的选择?</li><li>如何检测死锁？怎么预防死锁？</li></ol><h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。</p><p>比如，如果一个线程完成一个任务要100毫秒，那么用10个线程完成改任务只需10毫秒</p><h3 id="什么是线程安全和线程不安全？"><a href="#什么是线程安全和线程不安全？" class="headerlink" title="什么是线程安全和线程不安全？"></a>什么是线程安全和线程不安全？</h3><p>通俗的说：加锁的就是是线程安全的，不加锁的就是是线程不安全的</p><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全: 就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。</p><p>一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将<strong>集合类分成两组，线程安全和非线程安全的</strong>。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p><h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</p><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p><h3 id="什么是自旋锁？"><a href="#什么是自旋锁？" class="headerlink" title="什么是自旋锁？"></a>什么是自旋锁？</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>自旋锁是SMP架构中的一种low-level的同步机制</strong>。</p><p>当线程A想要获取一把自旋锁而该锁又被其它线程锁持有时，线程A会在一个循环中自旋以检测锁是不是已经可用了。</p><p><strong>自选锁需要注意</strong>：</p><ul><li><strong>由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直在那里自旋，这就会浪费CPU时间。</strong></li><li><strong>持有自旋锁的线程在sleep之前应该释放自旋锁以便其它线程可以获得自旋锁</strong>。</li></ul><h4 id="实现自旋锁"><a href="#实现自旋锁" class="headerlink" title="实现自旋锁"></a>实现自旋锁</h4><p>一个简单的while就可以满足你的要求。</p><p>目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyWaitNotify3</span><span class="token punctuation">{</span>  MonitorObject myMonitorObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MonitorObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span> wasSignalled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>myMonitorObject<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>wasSignalled<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>          myMonitorObject<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//clear signal and continue running.</span>      wasSignalled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doNotify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>myMonitorObject<span class="token punctuation">)</span><span class="token punctuation">{</span>      wasSignalled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      myMonitorObject<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="什么是Java内存模型？"><a href="#什么是Java内存模型？" class="headerlink" title="什么是Java内存模型？"></a>什么是Java内存模型？</h3><p>Java内存模型描述了在多线程代码中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了“程序中的变量“ 和 ”从内存或者寄存器获取或存储它们的底层细节”之间的关系。Java内存模型通过使用各种各样的硬件和编译器的优化来正确实现以上事情。</p><p>Java包含了几个语言级别的关键字，包括：volatile, final以及synchronized，目的是为了帮助程序员向编译器描述一个程序的并发需求。Java内存模型定义了volatile和synchronized的行为，更重要的是保证了同步的java程序在所有的处理器架构下面都能正确的运行。</p><p>“一个线程的写操作对其他线程可见”这个问题是因为编译器对代码进行重排序导致的。例如，只要代码移动不会改变程序的语义，当编译器认为程序中移动一个写操作到后面会更有效的时候，编译器就会对代码进行移动。如果编译器推迟执行一个操作，其他线程可能在这个操作执行完之前都不会看到该操作的结果，这反映了缓存的影响。</p><p>此外，写入内存的操作能够被移动到程序里更前的时候。在这种情况下，其他的线程在程序中可能看到一个比它实际发生更早的写操作。所有的这些灵活性的设计是为了通过给编译器，运行时或硬件灵活性使其能在最佳顺序的情况下来执行操作。在内存模型的限定之内，我们能够获取到更高的性能。</p><p>看下面代码展示的一个简单例子：</p><pre class="line-numbers language-java"><code class="language-java">Class <span class="token class-name">Reordering</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> r1 <span class="token operator">=</span> y<span class="token punctuation">;</span>        <span class="token keyword">int</span> r2 <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们看在两个并发线程中执行这段代码，读取Y变量将会得到2这个值。因为这个写入比写到X变量更晚一些，程序员可能认为读取X变量将肯定会得到1。但是，写入操作可能被重排序过。如果重排序发生了，那么，就能发生对Y变量的写入操作，读取两个变量的操作紧随其后，而且写入到X这个操作能发生。程序的结果可能是r1变量的值是2，但是r2变量的值为0。</p><p><strong>但是面试官，有时候不这么认为，认为就是JVM内存结构</strong></p><p>JVM内存结构主要有三大块：<strong>堆内存、方法区和栈</strong>。</p><p>堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，<strong>Eden空间、From Survivor空间、To Survivor空间</strong>,默认情况下年轻代按照8:1:1的比例来分配；<strong>方法区存储类信息、常量、静态变量等数据，是线程共享的区域</strong>，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。</p><p><strong>JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)</strong></p><p><strong>java堆（Java Heap）</strong></p><ul><li><strong>可通过参数 -Xms 和-Xmx设置</strong></li></ul><ol><li><strong>Java堆是被所有线程共享,是Java虚拟机所管理的内存中最大的一块 Java堆在虚拟机启动时创建</strong>。</li><li><strong>Java堆唯一的目的是存放对象实例，几乎所有的对象实例和数组都在这里</strong>。</li><li>Java堆为了便于更好的回收和分配内存，可以细分为：<strong>新生代和老年代</strong>；再细致一点的有<strong>Eden空间、From Survivor空间、To Survivor区</strong>。</li></ol><ul><li><strong>新生代</strong>：包括Eden区、From Survivor区、To Survivor区，系统默认大小Eden:Survivor=8:1。</li><li><strong>老年代</strong>：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</li></ul><ol><li>Survivor空间等Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可（就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的）。</li></ol><p><strong>据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常</strong>。</p><p><strong>java虚拟机栈(stack)</strong></p><p><strong>可通过参数 栈帧是方法运行期的基础数据结构栈容量可由-Xss设置</strong></p><p>1.<strong>Java虚拟机栈是线程私有的，它的生命周期与线程相同</strong>。</p><ol><li>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li><li>虚拟机栈是执行Java方法的内存模型(也就是字节码)服务：<strong>每个方法在执行的同时都会创建一个栈帧</strong>，<strong>用于存储 局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息。</li></ol><ul><li><strong>局部变量表</strong>：32位变量槽，存放了编译期可知的<strong>各种基本数据类型、对象引用、returnAddress类型</strong>。</li><li><strong>操作数栈</strong>：基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。</li><li><strong>动态连接</strong>：<strong>每个栈帧都包含一个指向运行时常量池（方法区的一部分）中该栈帧所属方法的引用</strong>。持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另一部分将在每一次的运行期间转化为直接应用，这部分称为动态连接</li><li><strong>方法出口</strong>：返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果无返回值，则把它压入调用者的操作数栈。</li></ul><ol><li><strong>局部变量表所需的内存空间在编译期间完成分配</strong>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的。</li><li><strong>在方法运行期间不会改变局部变量表的大小。主要存放了编译期可知的各种基本数据类型、对象引用</strong> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.runoob.com%2Fjava%2Fjava-basic-datatypes.html">（reference类型）、returnAddress类型）</a>。</li></ol><p><strong>java虚拟机栈,规定了两种异常状况：</strong></p><ol><li><strong>如果线程请求的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</strong>。</li><li><strong>如果虚拟机栈动态扩展，而扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常</strong>。</li></ol><p><strong>本地方法栈</strong></p><p><strong>可通过参数 栈容量可由-Xss设置</strong></p><ol><li>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务。</li><li>本地方法栈则是为虚拟机使用到的Native方法服务。有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一</li></ol><p><strong>方法区（Method Area）</strong></p><p><strong>可通过参数-XX:MaxPermSize设置</strong></p><ol><li><strong>线程共享内存区域，用于储存已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码，方法区也称持久代（Permanent Generation）</strong>。</li><li>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个<strong>别名叫做Non-Heap（非堆）</strong>，目的应该是与Java堆区分开来。</li><li>如何实现方法区，属于虚拟机的实现细节，不受虚拟机规范约束。</li><li>方法区主要存放java类定义信息，与垃圾回收关系不大，方法区可以选择不实现垃圾回收,但不是没有垃圾回收。</li><li><strong>方法区域的内存回收目标主要是针对常量池的回收和对类型的卸载</strong>。</li><li><strong>运行时常量池，也是方法区的一部分，虚拟机加载Class后把常量池中的数据放入运行时常量池</strong>。</li></ol><p><strong>运行时常量池</strong></p><p><strong>JDK1.6之前字符串常量池位于方法区之中</strong>。<strong>JDK1.7字符串常量池已经被挪到堆之中</strong>。</p><p><strong>可通过参数-XX:PermSize和-XX:MaxPermSize设置</strong></p><ul><li><strong>常量池</strong>（Constant Pool）：<strong>常量池数据编译期被确定，是Class文件中的一部分。存储了类、方法、接口等中的常量，当然也包括字符串常量</strong>。</li><li><strong>字符串池/字符串常量池</strong>（String Pool/String Constant Pool）：是常量池中的一部分，存储编译期类中产生的字符串类型数据。</li><li><strong>运行时常量池</strong>（Runtime Constant Pool）：<strong>方法区的一部分，所有线程共享。虚拟机加载Class后把常量池中的数据放入到运行时常量池</strong>。常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目资源关联最多的数据类型。</li></ul><ol><li>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference）。</li><li>字面量：文本字符串、声明为final的常量值等。</li><li>符号引用：类和接口的完全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。</li></ol><p><strong>直接内存</strong></p><p><strong>可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值（-Xmx指定）一样</strong>。</p><ul><li><strong>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现</strong>。</li></ul><p><strong>总结的简单一点</strong></p><p><strong>java堆（Java Heap）</strong></p><p>可通过参数 -Xms 和-Xmx设置</p><ol><li><strong>Java堆是被所有线程共享</strong>,是Java虚拟机所管理的内存中最大的一块 Java堆在虚拟机启动时创建</li><li>Java堆唯一的目的是<strong>存放对象实例，几乎所有的对象实例和数组都在这里</strong></li><li>Java堆为了便于更好的回收和分配内存，可以细分为：新生代和老年代；再细致一点的有<strong>Eden空间、From Survivor空间、To Survivor区</strong></li></ol><ul><li><strong>新生代</strong>：包括Eden区、From Survivor区、To Survivor区，系统默认大小Eden:Survivor=8:1。</li><li><strong>老年代</strong>：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</li></ul><p><strong>java虚拟机栈(stack)</strong></p><p>可通过参数 栈帧是方法运行期的基础数据结构栈容量可由-Xss设置</p><ol><li><strong>Java虚拟机栈是线程私有的，它的生命周期与线程相同</strong>。</li><li>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li><li>虚拟机栈是执行Java方法的内存模型(也就是字节码)服务：每个方法在执行的同时都会创建一个栈帧，<strong>用于存储 局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息</li></ol><p><strong>方法区（Method Area）</strong></p><p>可通过参数-XX:MaxPermSize设置</p><ol><li><strong>线程共享内存区域）</strong>，用于<strong>储存已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码</strong>，<strong>方法区也称持久代（Permanent Generation）</strong>。</li><li>方法区主要存放java类定义信息，与垃圾回收关系不大，方法区可以选择不实现垃圾回收,但不是没有垃圾回收。</li><li>方法区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</li><li><strong>运行时常量池，也是方法区的一部分，虚拟机加载Class后把常量池中的数据放入运行时常量池</strong>。</li></ol><h3 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h3><p><strong>CAS（compare and swap）的缩写，中文翻译成比较并交换</strong>。</p><p>CAS 不通过JVM,直接利用java本地方 JNI（Java Native Interface为JAVA本地调用）,直接调用CPU 的cmpxchg（是汇编指令）指令。</p><p><strong>利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法,实现原子操作。其它原子操作都是利用类似的特性完成的</strong>。</p><p>整个java.util.concurrent都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。</p><p><strong>CAS是项乐观锁技术</strong>，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><p><strong>CAS应用</strong></p><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><p><strong>CAS优点</strong></p><p>确保对内存的读-改-写操作都是原子操作执行</p><p><strong>CAS缺点</strong></p><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p><p><strong>总结</strong></p><ol><li><strong>使用CAS在线程冲突严重时，会大幅降低程序性能；CAS只适合于线程冲突较少的情况使用</strong>。</li><li><strong>synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS</strong>。</li></ol><p>参考<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.52itstyle.com%2Farchives%2F948%2F">blog.52itstyle.com/archives/94…</a></p><h3 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><h3 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h3><p>AbstractQueuedSynchronizer简称AQS，<strong>是一个用于构建锁和同步容器的框架</strong>。事实上concurrent包内许多类都是基于AQS构建，<strong>例如ReentrantLock</strong>，Semaphore，CountDownLatch，ReentrantReadWriteLock，<strong>FutureTask</strong>等。AQS解决了在实现同步容器时设计的大量细节问题。</p><p><strong>AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus。</strong></p><p><strong>CAS 原子操作在concurrent包的实现</strong></p><p>参考<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.52itstyle.com%2Farchives%2F948%2F">blog.52itstyle.com/archives/94…</a></p><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p><ul><li>A线程写volatile变量，随后B线程读这个volatile变量。</li><li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li></ul><p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p><p>首先，声明共享变量为volatile；然后，使用CAS的原子条件更新来实现线程之间的同步；</p><p>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</p><p>AQS，非阻塞数据结构和原子变量类（Java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。</p><p>AQS没有锁之类的概念，它有个state变量，是个int类型，在不同场合有着不同含义。</p><p>AQS围绕state提供两种基本操作“获取”和“释放”，有条双向队列存放阻塞的等待线程，并提供一系列判断和处理方法，简单说几点：</p><ul><li>state是独占的，还是共享的；</li><li>state被获取后，其他线程需要等待；</li><li>state被释放后，唤醒等待线程；</li><li>线程等不及时，如何退出等待。</li></ul><p>至于线程是否可以获得state，如何释放state，就不是AQS关心的了，要由子类具体实现。</p><p><strong>AQS中还有一个表示状态的字段state，例如ReentrantLocky用它表示线程重入锁的次数，Semaphore用它表示剩余的许可数量，FutureTask用它表示任务的状态。对state变量值的更新都采用CAS操作保证更新操作的原子性</strong>。</p><p>AbstractQueuedSynchronizer继承了AbstractOwnableSynchronizer，这个类只有一个变量：exclusiveOwnerThread，表示当前占用该锁的线程，并且提供了相应的get，set方法。</p><p>ReentrantLock实现原理</p><h3 id="什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？"><a href="#什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？" class="headerlink" title="什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？"></a>什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</h3><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p><p>int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。</p><p>为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。</p><p>到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。  </p><h3 id="什么是Executors框架？"><a href="#什么是Executors框架？" class="headerlink" title="什么是Executors框架？"></a>什么是Executors框架？</h3><p>Executor框架同java.util.concurrent.Executor 接口在Java 5中被引入。</p><p>Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p><p>无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。</p><p>利用Executors框架可以非常方便的创建一个线程池，</p><p>Java通过Executors提供四种线程池，分别为：</p><p><strong>newCachedThreadPool</strong>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p><strong>newFixedThreadPool</strong> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p><strong>newScheduledThreadPool</strong> 创建一个定长线程池，支持定时及周期性任务执行。</p><p><strong>newSingleThreadExecutor</strong> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。  </p><h3 id="什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"></a>什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</h3><p>JDK7提供了7个阻塞队列。（也属于并发容器）</p><ol><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ol><h4 id="什么是阻塞队列？"><a href="#什么是阻塞队列？" class="headerlink" title="什么是阻塞队列？"></a>什么是阻塞队列？</h4><p>阻塞队列是一个在队列基础上又支持了两个附加操作的队列。</p><p>2个附加操作：</p><p>支持阻塞的<strong>插入</strong>方法：队列满时，队列会阻塞插入元素的线程，直到队列不满。支持阻塞的<strong>移除</strong>方法：队列空时，获取元素的线程会等待队列变为非空。</p><h4 id="阻塞队列的应用场景"><a href="#阻塞队列的应用场景" class="headerlink" title="阻塞队列的应用场景"></a>阻塞队列的应用场景</h4><p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。简而言之，阻塞队列是生产者用来存放元素、消费者获取元素的容器。</p><p><strong>几个方法</strong></p><p>在阻塞队列不可用的时候，上述2个附加操作提供了四种处理方法</p><table><thead><tr><th><strong>方法\处理方式</strong></th><th><strong>抛出异常</strong></th><th><strong>返回特殊值</strong></th><th><strong>一直阻塞</strong></th><th><strong>超时退出</strong></th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除方法</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><p><strong>JAVA里的阻塞队列</strong></p><p>JDK 7 提供了7个阻塞队列，如下</p><p>1、<strong>ArrayBlockingQueue</strong> 数组结构组成的有界阻塞队列。</p><p>此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。</p><p>2、<strong>LinkedBlockingQueue</strong>一个由链表结构组成的有界阻塞队列</p><p>此队列按照先出先进的原则对元素进行排序</p><p>3、<strong>PriorityBlockingQueue</strong>支持优先级的无界阻塞队列</p><p>4、<strong>DelayQueue</strong>支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素</p><p>5、<strong>SynchronousQueue</strong>不存储元素的阻塞队列，每一个put必须等待一个take操作，否则不能继续添加元素。并且他支持公平访问队列。</p><p>6、<strong>LinkedTransferQueue</strong>由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，多了tryTransfer和transfer方法</p><p><strong>transfer方法</strong></p><p>如果当前有消费者正在等待接收元素（take或者待时间限制的poll方法），transfer可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的tail节点，并等到该元素被消费者消费了才返回。</p><p><strong>tryTransfer方法</strong></p><p>用来试探生产者传入的元素能否直接传给消费者。，如果没有消费者在等待，则返回false。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。</p><p>7、<strong>LinkedBlockingDeque</strong>链表结构的双向阻塞队列，优势在于多线程入队时，减少一半的竞争。</p><h4 id="如何使用阻塞队列来实现生产者-消费者模型？"><a href="#如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="如何使用阻塞队列来实现生产者-消费者模型？"></a>如何使用阻塞队列来实现生产者-消费者模型？</h4><p>通知模式实现：所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p><p><strong>使用BlockingQueue解决生产者消费者问题</strong></p><p><strong>为什么BlockingQueue适合解决生产者消费者问题</strong></p><p>任何有效的生产者-消费者问题解决方案都是通过控制生产者put()方法（生产资源）和消费者take()方法（消费资源）的调用来实现的，一旦你实现了对方法的阻塞控制，那么你将解决该问题。</p><p>Java通过BlockingQueue提供了开箱即用的支持来控制这些方法的调用（一个线程创建资源，另一个消费资源）。java.util.concurrent包下的BlockingQueue接口是一个线程安全的可用于存取对象的队列。</p><p><strong>BlockingQueue是一种数据结构，支持一个线程往里存资源，另一个线程从里取资源。这正是解决生产者消费者问题所需要的，那么让我们开始解决该问题吧。</strong></p><p><strong>生产者</strong></p><p>以下代码用于生产者线程</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> io<span class="token punctuation">.</span>ymq<span class="token punctuation">.</span>example<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 描述:生产者 * * @author yanpenglei * @create 2018-03-14 15:52 **/</span><span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> BlockingQueue<span class="token operator">&lt;</span>Object<span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token function">Producer</span><span class="token punctuation">(</span>BlockingQueue<span class="token operator">&lt;</span>Object<span class="token operator">></span> theQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> theQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Object justProduced <span class="token operator">=</span> <span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>justProduced<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者资源队列大小= "</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者 中断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    Object <span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者 读 中断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>消费者</strong></p><p>以下代码用于消费者线程</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> io<span class="token punctuation">.</span>ymq<span class="token punctuation">.</span>example<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 描述: 消费者 * * @author yanpenglei * @create 2018-03-14 15:54 **/</span><span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> BlockingQueue<span class="token operator">&lt;</span>Object<span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token function">Consumer</span><span class="token punctuation">(</span>BlockingQueue<span class="token operator">&lt;</span>Object<span class="token operator">></span> theQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> theQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Object obj <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者 资源 队列大小 "</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">take</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者 中断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">take</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// simulate time passing</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者 读 中断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费对象 "</span> <span class="token operator">+</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>测试该解决方案是否运行正常</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> io<span class="token punctuation">.</span>ymq<span class="token punctuation">.</span>example<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>LinkedBlockingQueue<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 描述: 测试 * * @author yanpenglei * @create 2018-03-14 15:58 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProducerConsumerExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">int</span> numProducers <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numConsumers <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        BlockingQueue<span class="token operator">&lt;</span>Object<span class="token operator">></span> myQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numProducers<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numConsumers<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-shell"><code class="language-shell">生产者资源队列大小= 1生产者资源队列大小= 1消费者 资源 队列大小 1生产者资源队列大小= 1消费者 资源 队列大小 1消费者 资源 队列大小 1生产者资源队列大小= 1生产者资源队列大小= 3消费对象 java.lang.Object@1e1aa52b生产者资源队列大小= 2生产者资源队列大小= 5消费对象 java.lang.Object@6e740a76消费对象 java.lang.Object@697853f6......消费对象 java.lang.Object@41a10cbc消费对象 java.lang.Object@4963c8d1消费者 资源 队列大小 5生产者资源队列大小= 5生产者资源队列大小= 5消费者 资源 队列大小 4消费对象 java.lang.Object@3e49c35d消费者 资源 队列大小 4生产者资源队列大小= 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果中,我们可以发现队列大小永远不会超过5，消费者线程消费了生产者生产的资源。</p><h3 id="什么是Callable和Future"><a href="#什么是Callable和Future" class="headerlink" title="什么是Callable和Future?"></a>什么是Callable和Future?</h3><p>Callable 和 Future 是比较有趣的一对组合。当我们需要获取线程的执行结果时，就需要用到它们。Callable用于产生结果，Future用于获取结果。</p><p>Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，必须等待它返回的结果。java.util.concurrent.Future对象解决了这个问题。</p><p>在线程池提交Callable任务后返回了一个Future对象，使用它可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法，等待Callable结束并获取它的执行结果。</p><p><strong>代码示例</strong></p><p>Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。</p><p>为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallableFutureTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"start main thread "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ExecutorService exec <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//新建一个Callable 任务，并将其提交到一个ExecutorService. 将返回一个描述任务情况的Future.</span>        Callable<span class="token operator">&lt;</span>String<span class="token operator">></span> call <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"start new thread "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end new thread "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token string">"我是返回的内容"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        Future<span class="token operator">&lt;</span>String<span class="token operator">></span> task <span class="token operator">=</span> exec<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>call<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String retn <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭线程池</span>        exec<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>retn <span class="token operator">+</span> <span class="token string">"--end main thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制台打印</p><pre class="line-numbers language-shell"><code class="language-shell">start main thread start new thread end new thread 我是返回的内容--end main thread<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="什么是FutureTask"><a href="#什么是FutureTask" class="headerlink" title="什么是FutureTask?"></a>什么是FutureTask?</h3><p>FutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，直接调用其run方法或者放入线程池执行，之后可以在外部通过FutureTask的get方法异步获取执行结果，因此，FutureTask非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。另外，FutureTask还可以确保即使调用了多次run方法，它都只会执行一次Runnable或者Callable任务，或者通过cancel取消FutureTask的执行等。</p><p><strong>1.执行多任务计算</strong></p><p>FutureTask执行多任务计算的使用场景</p><p>利用FutureTask和ExecutorService，可以用多线程的方式提交计算任务，主线程继续执行其他任务，当主线程需要子线程的计算结果时，在异步获取子线程的执行结果。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTaskForMultiCompute</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        FutureTaskForMultiCompute inst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTaskForMultiCompute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建任务集合</span>        List<span class="token operator">&lt;</span>FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> taskList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建线程池</span>        ExecutorService exec <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 传入Callable对象创建FutureTask对象</span>            FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span>inst<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">ComputeTask</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">""</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            taskList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ft<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 提交给线程池执行任务，也可以通过exec.invokeAll(taskList)一次性提交所有任务;</span>            exec<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>ft<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有计算任务提交完毕, 主线程接着干其他事情！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 开始统计各计算线程计算结果</span>        Integer totalResult <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ft <span class="token operator">:</span> taskList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//FutureTask的get方法会自动阻塞,直到获取计算结果为止</span>                totalResult <span class="token operator">=</span> totalResult <span class="token operator">+</span> ft<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 关闭线程池</span>        exec<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"多任务计算后的总结果是:"</span> <span class="token operator">+</span> totalResult<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ComputeTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> Integer result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> String taskName <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">ComputeTask</span><span class="token punctuation">(</span>Integer iniResult<span class="token punctuation">,</span> String taskName<span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> iniResult<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>taskName <span class="token operator">=</span> taskName<span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生成子线程计算任务: "</span> <span class="token operator">+</span> taskName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> String <span class="token function">getTaskName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>taskName<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> <span class="token operator">+</span>i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 休眠5秒钟，观察主线程行为，预期的结果是主线程会继续执行，到要取得FutureTask的结果是等待直至完成。</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程计算任务: "</span> <span class="token operator">+</span> taskName <span class="token operator">+</span> <span class="token string">" 执行完成!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-shell"><code class="language-shell">生成子线程计算任务: 0生成子线程计算任务: 1生成子线程计算任务: 2生成子线程计算任务: 3生成子线程计算任务: 4生成子线程计算任务: 5生成子线程计算任务: 6生成子线程计算任务: 7生成子线程计算任务: 8生成子线程计算任务: 9所有计算任务提交完毕, 主线程接着干其他事情！子线程计算任务: 0 执行完成!子线程计算任务: 2 执行完成!子线程计算任务: 3 执行完成!子线程计算任务: 4 执行完成!子线程计算任务: 1 执行完成!子线程计算任务: 8 执行完成!子线程计算任务: 7 执行完成!子线程计算任务: 6 执行完成!子线程计算任务: 9 执行完成!子线程计算任务: 5 执行完成!多任务计算后的总结果是:990<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.高并发环境下</strong></p><p>FutureTask在高并发环境下确保任务只执行一次</p><p>在很多高并发的环境下，往往我们只需要某些任务只执行一次。这种使用情景FutureTask的特性恰能胜任。举一个例子，假设有一个带key的连接池，当key存在时，即直接返回key对应的对象；当key不存在时，则创建连接。对于这样的应用场景，通常采用的方法为使用一个Map对象来存储key和连接池对应的对应关系，典型的代码如下面所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Connection<span class="token operator">></span> connectionPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Connection<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Connection <span class="token function">getConnection</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>connectionPool<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> connectionPool<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//创建 Connection  </span>                Connection conn <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                connectionPool<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> conn<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> conn<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//创建Connection  </span>    <span class="token keyword">private</span> Connection <span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，我们通过加锁确保高并发环境下的线程安全，也确保了connection只创建一次，然而确牺牲了性能。改用ConcurrentHash的情况下，几乎可以避免加锁的操作，性能大大提高，但是在高并发的情况下有可能出现Connection被创建多次的现象。这时最需要解决的问题就是当key不存在时，创建Connection的动作能放在connectionPool之后执行，这正是FutureTask发挥作用的时机，基于ConcurrentHashMap和FutureTask的改造代码如下：</p><pre class="line-numbers language-java"><code class="language-java">  <span class="token keyword">private</span> ConcurrentHashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> FutureTask<span class="token operator">&lt;</span>Connection<span class="token operator">>></span> connectionPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> FutureTask<span class="token operator">&lt;</span>Connection<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Connection <span class="token function">getConnection</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        FutureTask<span class="token operator">&lt;</span>Connection<span class="token operator">></span> connectionTask <span class="token operator">=</span> connectionPool<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>connectionTask <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> connectionTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            Callable<span class="token operator">&lt;</span>Connection<span class="token operator">></span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Connection<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> Connection <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// TODO Auto-generated method stub  </span>                    <span class="token keyword">return</span> <span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            FutureTask<span class="token operator">&lt;</span>Connection<span class="token operator">></span> newTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>Connection<span class="token operator">></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>            connectionTask <span class="token operator">=</span> connectionPool<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> newTask<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>connectionTask <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                connectionTask <span class="token operator">=</span> newTask<span class="token punctuation">;</span>                connectionTask<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> connectionTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//创建Connection  </span>    <span class="token keyword">private</span> Connection <span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过这样的改造，可以避免由于并发带来的多次创建连接及锁的出现。</p><h3 id="什么是同步容器和并发容器的实现？"><a href="#什么是同步容器和并发容器的实现？" class="headerlink" title="什么是同步容器和并发容器的实现？"></a>什么是同步容器和并发容器的实现？</h3><h4 id="一、同步容器"><a href="#一、同步容器" class="headerlink" title="一、同步容器"></a>一、同步容器</h4><p>主要代表有Vector和Hashtable，以及Collections.synchronizedXxx等。锁的粒度为当前对象整体。迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛出ConcurrentModificationException。</p><h4 id="二、并发容器"><a href="#二、并发容器" class="headerlink" title="二、并发容器"></a>二、并发容器</h4><p>主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。锁的粒度是分散的、细粒度的，即读和写是使用不同的锁。迭代器具有弱一致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。</p><p><strong>JDK 7 ConcurrentHashMap</strong></p><p>采用分离锁技术，同步容器中，是一个容器一个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若干段，每段维护一个锁，以达到高效的并发访问；</p><p><strong>JDK 8 ConcurrentHashMap</strong></p><p>采用分离锁技术，同步容器中，是一个容器一个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若干段，每段维护一个锁，以达到高效的并发访问；</p><h4 id="三、阻塞队列"><a href="#三、阻塞队列" class="headerlink" title="三、阻塞队列"></a>三、阻塞队列</h4><p>主要代表有LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue(Comparable,Comparator)、SynchronousQueue。提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。适用于生产者、消费者模式（线程池和工作队列-Executor），同时也是同步容器</p><h4 id="四、双端队列"><a href="#四、双端队列" class="headerlink" title="四、双端队列"></a>四、双端队列</h4><p>主要代表有ArrayDeque和LinkedBlockingDeque。意义：正如阻塞队列适用于生产者消费者模式，双端队列同样适用与另一种模式，即工作密取。在生产者-消费者设计中，所有消费者共享一个工作队列，而在工作密取中，每个消费者都有各自的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么他就可以从其他消费者的双端队列末尾秘密的获取工作。具有更好的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。在大多数时候，他们都只是访问自己的双端队列，从而极大的减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争。适用于：网页爬虫等任务中</p><h4 id="五、比较及适用场景"><a href="#五、比较及适用场景" class="headerlink" title="五、比较及适用场景"></a>五、比较及适用场景</h4><p>如果不需要阻塞队列，优先选择ConcurrentLinkedQueue；如果需要阻塞队列，队列大小固定优先选择ArrayBlockingQueue，队列大小不固定优先选择LinkedBlockingQueue；如果需要对队列进行排序，选择PriorityBlockingQueue；如果需要一个快速交换的队列，选择SynchronousQueue；如果需要对队列中的元素进行延时操作，则选择DelayQueue。</p><h3 id="什么是多线程？优缺点？"><a href="#什么是多线程？优缺点？" class="headerlink" title="什么是多线程？优缺点？"></a>什么是多线程？优缺点？</h3><p><strong>什么是多线程？</strong></p><p>多线程：是指从软件或者硬件上实现多个线程的并发技术。</p><p><strong>多线程的好处：</strong></p><ol><li>使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视频的下载</li><li>发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好</li></ol><p><strong>多线程的缺点：</strong></p><ol><li>大量的线程降低代码的可读性；</li><li>更多的线程需要更多的内存空间</li><li>当多个线程对同一个资源出现争夺时候要注意线程安全的问题。</li></ol><h3 id="什么是多线程的上下文切换？"><a href="#什么是多线程的上下文切换？" class="headerlink" title="什么是多线程的上下文切换？"></a>什么是多线程的上下文切换？</h3><p>即使是单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程时同时执行的，时间片一般是几十毫秒（ms）</p><p><strong>上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行</strong></p><p><strong>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态</strong></p><ul><li><strong>从任务保存到再加载的过程就是一次上下文切换</strong></li></ul><p><strong>ThreadLocal的设计理念与作用？</strong></p><p>Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量</p><p><strong>ThreadLocal</strong></p><p><strong>如何创建ThreadLocal变量</strong></p><p>以下代码展示了如何创建一个ThreadLocal变量：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> ThreadLocal myThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过这段代码实例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它是被哪个线程实例化。虽然<strong>所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的set()方法设置的值。即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值，他们仍然无法访问到对方的值</strong>。</p><p><strong>如何访问ThreadLocal变量</strong></p><p>一旦创建了一个ThreadLocal变量，你可以通过如下代码设置某个需要保存的值：</p><pre class="line-numbers language-java"><code class="language-java">myThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>"A thread local value”<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以通过下面方法读取保存在ThreadLocal变量中的值：</p><pre class="line-numbers language-java"><code class="language-java">String threadLocalValue <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> myThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>get()方法返回一个Object对象，set()对象需要传入一个Object类型的参数。</p><p><strong>为ThreadLocal指定泛型类型</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ThreadLocal<span class="token operator">&lt;</span>String<span class="token operator">></span> myThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以创建一个指定泛型类型的ThreadLocal对象，这样我们就不需要每次对使用get()方法返回的值作强制类型转换了。下面展示了指定泛型类型的ThreadLocal例子：</p><p><strong>ThreadLocal的设计理念与作用</strong></p><p><a href="http://blog.csdn.net/u011860731/article/details/48733073http://blog.csdn.net/u011860731/article/details/48733073" target="_blank" rel="noopener">http://blog.csdn.net/u011860731/article/details/48733073http://blog.csdn.net/u011860731/article/details/48733073</a>)</p><p><strong>InheritableThreadLocal</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ThreadLocal<span class="token operator">&lt;</span>Integer<span class="token operator">></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InheritableThreadLocal</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>InheritableThreadLocal类是ThreadLocal类的子类。ThreadLocal中每个线程拥有它自己的值，与ThreadLocal不同的是，<strong>InheritableThreadLocal允许一个线程以及该线程创建的所有子线程都可以访问它保存的值</strong>。</p><p><strong>InheritableThreadLocal 原理</strong></p><p><strong>Java 多线程：InheritableThreadLocal 实现原理</strong></p><p><a href="https://link.juejin.im?target=http%3A%2F%2Fblog.csdn.net%2Fni357103403%2Farticle%2Fdetails%2F51970748">blog.csdn.net/ni357103403…</a></p><h3 id="ThreadPool（线程池）用法与优势？"><a href="#ThreadPool（线程池）用法与优势？" class="headerlink" title="ThreadPool（线程池）用法与优势？"></a>ThreadPool（线程池）用法与优势？</h3><p><strong>为什么要用线程池？</strong></p><ol><li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li><li>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</li></ol><p><strong>new Thread 缺点</strong></p><ol><li>每次new Thread新建对象性能差。</li><li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。</li><li>缺乏更多功能，如定时执行、定期执行、线程中断。</li></ol><p><strong>ThreadPool 优点</strong></p><p>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</p><p>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)</p><ul><li>减少在创建和销毁线程上所花的时间以及系统资源的开销</li><li>如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存</li></ul><p><strong>Java提供的四种线程池的好处在于</strong>：</p><ol><li>重用存在的线程，减少对象创建、销毁的开销，提高性能。</li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ol><p><strong>比较重要的几个类：</strong></p><table><thead><tr><th><strong>类</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>ExecutorService</td><td>真正的线程池接口。</td></tr><tr><td>ScheduledExecutorService</td><td>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</td></tr><tr><td>ThreadPoolExecutor</td><td>ExecutorService的默认实现。</td></tr><tr><td>ScheduledThreadPoolExecutor</td><td>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</td></tr></tbody></table><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。</p><p><strong>Executors提供四种线程池</strong></p><p><strong>newCachedThreadPool</strong>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p><strong>newFixedThreadPool</strong> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p><strong>newScheduledThreadPool</strong> 创建一个定长线程池，支持定时及周期性任务执行。</p><p><strong>newSingleThreadExecutor</strong> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><p><strong>一般都不用Executors提供的线程创建方式</strong></p><p><strong>使用ThreadPoolExecutor创建线程池</strong></p><p><strong>ThreadPoolExecutor的构造函数</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                              ThreadFactory threadFactory<span class="token punctuation">,</span>                              RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数：</strong></p><ol><li><strong>corePoolSize</strong>核心线程数大小，当线程数&lt;corePoolSize ，会创建线程执行runnable</li><li><strong>maximumPoolSize</strong> 最大线程数， 当线程数 &gt;= corePoolSize的时候，会把runnable放入workQueue中</li><li><strong>keepAliveTime</strong> 保持存活时间，当线程数大于corePoolSize的空闲线程能保持的最大时间。</li><li><strong>unit</strong> 时间单位</li><li><strong>workQueue</strong> 保存任务的阻塞队列</li><li><strong>threadFactory</strong> 创建线程的工厂</li><li><strong>handler</strong> 拒绝策略</li></ol><p><strong>任务执行顺序：</strong></p><ol><li>当线程数小于corePoolSize时，创建线程执行任务。</li><li>当线程数大于等于corePoolSize并且workQueue没有满时，放入workQueue中</li><li>线程数大于等于corePoolSize并且当workQueue满时，新任务新建线程运行，线程总数要小于maximumPoolSize</li><li>当线程总数等于maximumPoolSize并且workQueue满了的时候执行handler的rejectedExecution。也就是拒绝策略。</li></ol><p><strong>ThreadPoolExecutor默认有四个拒绝策略：</strong></p><ol><li>ThreadPoolExecutor.AbortPolicy() 直接抛出异常RejectedExecutionException</li><li>ThreadPoolExecutor.CallerRunsPolicy() 直接调用run方法并且阻塞执行</li><li>ThreadPoolExecutor.DiscardPolicy() 直接丢弃后来的任务</li><li>ThreadPoolExecutor.DiscardOldestPolicy() 丢弃在队列中队首的任务</li></ol><p>当然可以自己继承 RejectedExecutionHandler 来写拒绝策略.</p><p><strong>java 四种线程池的使用</strong></p><p><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F59df0c1af265da432f301c8d">juejin.im/post/59df0c…</a></p><h3 id="Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等"><a href="#Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等" class="headerlink" title="Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等"></a>Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等</h3><p><strong>阻塞队列</strong></p><p>1、<strong>ArrayBlockingQueue</strong> 数组结构组成的有界阻塞队列。</p><p>此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。</p><p><strong>CountDownLatch</strong></p><p>CountDownLatch 允许一个或多个线程等待其他线程完成操作。</p><p><strong>应用场景</strong></p><p>假如有这样一个需求，当我们需要解析一个Excel里多个sheet的数据时，可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完成。</p><p>在这个需求中，要实现主线程等待所有线程完成sheet的解析操作，最简单的做法是使用join。代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JoinCountDownLatchTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread parser1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread parser2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"parser2 finish"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        parser1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        parser2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        parser1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        parser2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"all parser finish"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远wait，代码片段如下，wait(0)表示永远等待下去。</p><p>while (isAlive()) { wait(0); } </p><ul><li>方法isAlive()功能是判断当前线程是否处于活动状态。</li><li>活动状态就是线程启动且尚未终止，比如正在运行或准备开始运行。</li></ul><p><strong>CountDownLatch用法</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> CountDownLatch latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">try</span> <span class="token punctuation">{</span>                     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"正在执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>             <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">try</span> <span class="token punctuation">{</span>                     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"正在执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>             <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">try</span> <span class="token punctuation">{</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待2个子线程执行完毕..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2个子线程已经执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"继续执行主线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程Thread-0正在执行 </p><p>线程Thread-1正在执行 </p><p>等待2个子线程执行完毕…</p><p>线程Thread-0执行完毕 </p><p>线程Thread-1执行完毕 </p><p>2个子线程已经执行完毕 </p><p>继续执行主线程 </p><p>new CountDownLatch(2)的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。</p><p>当我们调用一次CountDownLatch的countDown()方法时，N就会减1，CountDownLatch的await()会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，你只需要把这个CountDownLatch的引用传递到线程里。</p><p><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.importnew.com%2F21889.html">Java并发编程：CountDownLatch、CyclicBarrier和 Semaphore</a></p><p><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.importnew.com%2F21889.html">www.importnew.com/21889.html</a></p><h3 id="synchronized和ReentrantLock的区别？"><a href="#synchronized和ReentrantLock的区别？" class="headerlink" title="synchronized和ReentrantLock的区别？"></a>synchronized和ReentrantLock的区别？</h3><p>java在编写多线程程序时，为了保证线程安全，需要对数据同步，经常用到两种同步方式就是Synchronized和重入锁ReentrantLock。</p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li><strong>可重入锁</strong>。可重入锁是指同一个线程可以多次获取同一把锁。<strong>ReentrantLock和synchronized都是可重入锁</strong>。</li><li><strong>可中断锁</strong>。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，而ReentrantLock则提供了中断功能。</li><li><strong>公平锁与非公平锁</strong>。公平锁是指多个线程同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，而非公平锁则允许线程“插队”。synchronized是非公平锁，而ReentrantLock的默认实现是非公平锁，但是也可以设置为公平锁。</li><li><strong>CAS操作(CompareAndSwap)</strong>。CAS操作简单的说就是比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”</li></ul><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><p>synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。然而synchronized也有一定的局限性</p><p>例如：</p><ol><li>当线程尝试获取锁的时候，如果获取不到锁会一直阻塞。</li><li>如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。</li></ol><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。</p><p>代码示例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">try</span><span class="token punctuation">{</span>         <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// ignored</span>     <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>         lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>lock()</strong>, 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁</li><li><strong>tryLock()</strong>, 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；</li><li><strong>tryLock(long timeout,TimeUnit unit)</strong>，如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；</li><li><strong>lockInterruptibly</strong>:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断</li></ul><p><strong>ReentrantLock 一些特性</strong></p><ol><li><strong>等待可中断避免，出现死锁的情况</strong>（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false）</li><li><strong>公平锁与非公平锁</strong>多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，<strong>ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁</strong>，但公平锁表现的性能不是很好。</li></ol><p>公平锁：线程获取锁的顺序和调用lock的顺序一样，FIFO；</p><p>非公平锁：线程获取锁的顺序和调用lock的顺序无关，全凭运气。</p><p><strong>Java并发包(java.util.concurrent)中大量使用了CAS操作,涉及到并发的地方都调用了sun.misc.Unsafe类方法进行CAS操作</strong>。</p><p><strong>ReenTrantLock实现的原理：</strong></p><p>简单来说，<strong>ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁</strong>。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p><p><strong>总结一下</strong></p><p>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p><p><strong>synchronized</strong>：</p><p>在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好。</p><p><strong>ReentrantLock</strong>:</p><p>ReentrantLock用起来会复杂一些。在基本的加锁和解锁上，两者是一样的，所以无特殊情况下，推荐使用synchronized。ReentrantLock的优势在于它更灵活、更强大，增加了轮训、超时、中断等高级功能。</p><p>ReentrantLock默认<strong>使用非公平锁是基于性能考虑</strong>，公平锁为了保证线程规规矩矩地排队，需要增加阻塞和唤醒的时间开销。如果直接插队获取非公平锁，跳过了对队列的处理，速度会更快。</p><p><strong>ReentrantLock实现原理</strong></p><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fmaypattis%2Fp%2F6403682.html">www.cnblogs.com/maypattis/p…</a></p><p><strong>分析ReentrantLock的实现原理</strong>(ReentrantLock和同步工具类的实现基础都是AQS)</p><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Ffe027772e156">www.jianshu.com/p/fe027772e…</a></p><h3 id="Semaphore有什么作用？"><a href="#Semaphore有什么作用？" class="headerlink" title="Semaphore有什么作用？"></a>Semaphore有什么作用？</h3><ol><li>Semaphore就是一个信号量，<strong>它的作用是限制某段代码块的并发数</strong>。</li><li>Semaphore有一个构造函数，可以<strong>传入一个int型整数n，表示某段代码最多只有n个线程可以访问</strong>，</li><li><strong>如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入</strong>。</li><li>由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</li></ol><p>Semaphore类位于java.util.concurrent包下，它提供了2个构造器：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//参数permits表示许可数目，即同时可以允许多少线程进行访问  </span><span class="token keyword">public</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">)</span> <span class="token punctuation">{</span>      sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span>permits<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可  </span><span class="token keyword">public</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>      sync <span class="token operator">=</span> <span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span>permits<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span>permits<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Semaphore类中比较重要的几个方法，首先是acquire()、release()方法：</li><li>acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</li><li>release()用来释放许可。注意，在释放许可之前，必须先获获得许可。</li></ul><p>Semaphore类中比较重要的几个方法，首先是acquire()、release()方法： acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。 release()用来释放许可。注意，在释放许可之前，必须先获获得许可。 </p><p>这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false  </span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false  </span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false  </span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true  </span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//得到当前可用的许可数目  </span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">availablePermits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例</strong></p><p>假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//工人数  </span>        Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//机器数目  </span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>              <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>semaphore<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>          <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>          <span class="token keyword">private</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>          <span class="token keyword">private</span> Semaphore semaphore<span class="token punctuation">;</span>          <span class="token keyword">public</span> <span class="token function">Worker</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span>Semaphore semaphore<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>semaphore <span class="token operator">=</span> semaphore<span class="token punctuation">;</span>          <span class="token punctuation">}</span>                  <span class="token annotation punctuation">@Override</span>          <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">try</span> <span class="token punctuation">{</span>                  semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"工人"</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token operator">+</span><span class="token string">"占用一个机器在生产..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"工人"</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token operator">+</span><span class="token string">"释放出机器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-shell"><code class="language-shell">工人0占用一个机器在生产...  工人1占用一个机器在生产...  工人2占用一个机器在生产...  工人4占用一个机器在生产...  工人5占用一个机器在生产...  工人0释放出机器  工人2释放出机器  工人3占用一个机器在生产...  工人7占用一个机器在生产...  工人4释放出机器  工人5释放出机器  工人1释放出机器  工人6占用一个机器在生产...  工人3释放出机器  工人7释放出机器  工人6释放出机器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？"></a>Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</h3><p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p><p>它的优势有：</p><ul><li>可以使锁更公平</li><li>可以使线程在等待锁的时候响应中断</li><li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li><li>可以在不同的范围，以不同的顺序获取和释放锁</li></ul><p><strong>Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</strong></p><p>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。</p><p><strong>而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</strong></p><p><strong>ConcurrentHashMap的并发度是什么？</strong></p><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势</p><p><strong>ReentrantReadWriteLock读写锁的使用</strong></p><p>Lock比传统线程模型中的synchronized方式更加面向对象，与生活中的锁类似，锁本身也应该是一个对象。两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个Lock对象。</p><p><strong>读写锁</strong>：<strong>分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可</strong>。<strong>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</strong>；</p><p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！</p><p><strong>ReentrantReadWriteLock会使用两把锁来解决问题，一个读锁，一个写锁</strong></p><p><strong>线程进入读锁的前提条件</strong>：</p><ul><li><strong>没有其他线程的写锁</strong></li><li><strong>没有写请求或者有写请求，但调用线程和持有锁的线程是同一个</strong></li></ul><p><strong>线程进入写锁的前提条件</strong>：</p><ul><li><strong>没有其他线程的读锁</strong></li><li><strong>没有其他线程的写锁</strong></li><li>读锁的重入是允许多个申请读操作的线程的，而写锁同时只允许单个线程占有，该线程的写操作可以重入。</li><li>如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。</li><li>对于同时占有读锁和写锁的线程，如果完全释放了写锁，那么它就完全转换成了读锁，以后的写操作无法重入，在写锁未完全释放时写操作是可以重入的。</li><li>公平模式下无论读锁还是写锁的申请都必须按照AQS锁等待队列先进先出的顺序。非公平模式下读操作插队的条件是锁等待队列head节点后的下一个节点是SHARED型节点，写锁则无条件插队。</li><li>读锁不允许newConditon获取Condition接口，而写锁的newCondition接口实现方法同ReentrantLock。</li></ul><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【排序算法】——开篇</title>
      <link href="/posts/e57b.html"/>
      <url>/posts/e57b.html</url>
      
        <content type="html"><![CDATA[<p><strong>0、排序算法说明</strong></p><p><strong>0.1 排序的定义</strong></p><p>对一序列对象根据某个关键字进行排序。</p><p><strong>0.2 术语说明</strong></p><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</li></ul><p><strong>0.3 算法总结</strong></p><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【排序算法】——冒泡排序</title>
      <link href="/posts/8303.html"/>
      <url>/posts/8303.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 冒泡排序 * * 原理描述：比较相邻两个元素大小，进行交换，将大（小）的元素放到右边，以此类推，直到排序完毕。 * * 平均时间复杂度 O(n^2) 空间复杂度 O(1) 稳定 * * @param array 数组 * @return int[] */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> array<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 没有数据交换提前退出循环</span>    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务的隔离级别</title>
      <link href="/posts/8b21.html"/>
      <url>/posts/8b21.html</url>
      
        <content type="html"><![CDATA[<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>数据库事务的隔离级别有4个，由低到高依次为：</p><ul><li>Read uncommitted（读未提交）</li><li>Read committed（读提交）</li><li>Repeatable read （重复读）</li><li>Serializable（串行化）</li></ul><p>这四个级别可以逐个解决<strong>脏读、不可重复读、幻读</strong>这几类问题，具体见下表。</p><p>√: 可能出现  ×: 不会出现</p><table><thead><tr><th>事务的隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted 读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed–读提交 Sql Server , Oracle默认</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable read–重复读 MySQL默认</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable 串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>注意：我们讨论隔离级别的场景，主要是在多个事务并发的情况下，因此，接下来的讲解都围绕<strong>事务并发</strong>。 </p><h4 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted 读未提交"></a>Read uncommitted 读未提交</h4><p>Read Uncommitted是限制性最弱的隔离级别，因为该级别忽略其他事务放置的锁。使用Read Uncommitted级别执行的事务，可以读取尚未由其他事务提交的修改后的数据值，这些行为称为“脏”读。这是因为在Read Uncommitted级别下，读取数据不需要加S锁，这样就不会跟被修改的数据上的X锁冲突。</p><p>比如，事务1修改一行，事务2在事务1提交之前读取了这一行。如果事务1回滚，事务2就读取了一行没有提交的数据，这样的数据我们认为是不存在的。</p><p>当隔离级别设置为Read uncommitted时，就可能出现脏读，看以下案例。</p><p>公司发工资了，领导把5000元打到 A 的账号上，但是该事务并未提交，而 A 正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给 A 的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后 A 实际的工资只有2000元，A 空欢喜一场。</p><p>两个并发的事务，“事务1：领导给 A 发工资”、“事务2：A 查询工资账户”，事务2读取了事务1尚未提交的数据，即我们所说的脏读。</p><h4 id="Read-committed-读提交"><a href="#Read-committed-读提交" class="headerlink" title="Read committed 读提交"></a>Read committed 读提交</h4><p>Read committed(Nonrepeatable reads)是SQL Server、Oracle默认的隔离级别。该级别通过指定语句不能读取其他事务已修改但是尚未提交的数据值，禁止执行脏读。在当前事务中的各个语句执行之间，其他事务仍可以修改、插入或删除数据，从而产生无法重复的读操作，或“影子”数据。</p><p>比如，事务1读取了一行，事务2修改或者删除这一行并且提交。如果事务1想再一次读取这一行，它将获得修改后的数据或者发现这一样已经被删除，因此事务1的第二次读取结果与第一次读取结果不同，因此也叫不可重复读。</p><p>A 拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把A工资卡的2000元转到另一账户，并在A之前提交了事务，当A扣款时，系统检查到 A 的工资卡已经没有钱，扣款失败，A 十分纳闷，明明卡里有钱的。</p><p>两个并发的事务，“事务1：A消费”、“事务2：A 的老婆网上转账”，事务1事先读取了数据，事务2紧接了更新了数据，并提交了事务，而事务1再次读取该数据时，数据已经发生了改变，出现了不可重复读。</p><p>当隔离级别设置为Read committed时，避免了脏读，但是可能会造成不可重复读。大多数数据库的默认级别就是Read committed（读提交），比如 <strong>Sql Server ,</strong> <strong>Oracle</strong></p><h4 id="Repeatable-read-重复读"><a href="#Repeatable-read-重复读" class="headerlink" title="Repeatable read 重复读"></a>Repeatable read 重复读</h4><p>当隔离级别设置为Repeatable read时，可以避免不可重复读。当 A 拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），A 的老婆就不可能对该记录进行修改，也就是 A 的老婆不能在此时转账。</p><p>避免不可重复读，“事物1：A 消费”，“事物2：A的老婆网上转账”，事务1开始，未提交，事物2不能进行。</p><p>虽然Repeatable read避免了不可重复读，但还有可能出现幻读。</p><p>A 的老婆工作在银行部门，她时常通过银行内部系统查看 A 的信用卡消费记录。有一天，她正在查询到 A 当月信用卡的总消费金额（select sum(amount) from transaction where month = 本月）为80元，而 A 此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction … ），并提交了事务，随后 A 的老婆将 A 当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，A 的老婆很诧异，以为出现了幻觉，幻读就这样产生了。</p><p>注：MySQL的默认隔离级别就是Repeatable read（重复读）</p><h4 id="Serializable-串行化"><a href="#Serializable-串行化" class="headerlink" title="Serializable 串行化"></a>Serializable 串行化</h4><p>Serializable是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻读。</p><hr><p><em>关注微信公众号:</em>【皮卡战记】</p><img src="../images/loading.gif" data-original="http://img.wenlincheng.com/20200306123730.jpg" alt="皮卡战记" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
